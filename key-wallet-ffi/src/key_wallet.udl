namespace key_wallet_ffi {
    // Initialize the library (for any global setup)
    void initialize();
    
    // Validate a mnemonic phrase
    [Throws=KeyWalletError]
    boolean validate_mnemonic(string phrase, Language language);
};

// Network enum
enum Network {
    "Dash",
    "Testnet",
    "Regtest",
    "Devnet",
};

// Language enum for mnemonics
enum Language {
    "English",
    "ChineseSimplified",
    "ChineseTraditional", 
    "French",
    "Italian",
    "Japanese",
    "Korean",
    "Spanish",
};

// Address type enum
enum AddressType {
    "P2PKH",
    "P2SH",
};

// Error types
[Error]
enum KeyWalletError {
    "InvalidMnemonic",
    "InvalidDerivationPath",
    "KeyError",
    "Secp256k1Error",
    "AddressError",
};

// Derivation path type
dictionary DerivationPath {
    string path;
};

// Account extended keys
dictionary AccountXPriv {
    string derivation_path;
    string xpriv;
};

dictionary AccountXPub {
    string derivation_path;
    string xpub;
    sequence<u8>? pub_key;
};

// Mnemonic interface
interface Mnemonic {
    // Create from phrase
    [Throws=KeyWalletError, Name="new"]
    constructor(string phrase, Language language);
    
    // Generate a new mnemonic
    [Throws=KeyWalletError, Name="generate"]
    constructor(Language language, u8 word_count);
    
    // Get the phrase
    string phrase();
    
    // Convert to seed with optional passphrase
    sequence<u8> to_seed(string passphrase);
};

// HD Wallet interface
interface HDWallet {
    // Create from seed
    [Throws=KeyWalletError, Name="from_seed"]
    constructor(sequence<u8> seed, Network network);
    
    // Create from mnemonic
    [Throws=KeyWalletError, Name="from_mnemonic"]
    constructor(Mnemonic mnemonic, string passphrase, Network network);
    
    // Get account extended private key
    [Throws=KeyWalletError]
    AccountXPriv get_account_xpriv(u32 account);
    
    // Get account extended public key
    [Throws=KeyWalletError]
    AccountXPub get_account_xpub(u32 account);
    
    // Get identity authentication key at index
    [Throws=KeyWalletError]
    sequence<u8> get_identity_authentication_key_at_index(u32 identity_index, u32 key_index);
    
    // Derive a key at path
    [Throws=KeyWalletError]
    string derive_xpriv(string path);
    
    // Derive a public key at path
    [Throws=KeyWalletError]
    AccountXPub derive_xpub(string path);
};

// Extended Private Key interface
interface ExtPrivKey {
    // Create from string
    [Throws=KeyWalletError, Name="from_string"]
    constructor(string xpriv);
    
    // Get extended public key
    AccountXPub get_xpub();
    
    // Derive child
    [Throws=KeyWalletError]
    ExtPrivKey derive_child(u32 index, boolean hardened);
    
    // Serialize to string
    string to_string();
};

// Extended Public Key interface
interface ExtPubKey {
    // Create from string
    [Throws=KeyWalletError, Name="from_string"]
    constructor(string xpub);
    
    // Derive child
    [Throws=KeyWalletError]
    ExtPubKey derive_child(u32 index);
    
    // Get public key bytes
    sequence<u8> get_public_key();
    
    // Serialize to string
    string to_string();
};

// Address interface
interface Address {
    // Parse from string
    [Throws=KeyWalletError, Name="from_string"]
    constructor(string address, Network network);
    
    // Create from public key
    [Throws=KeyWalletError, Name="from_public_key"]
    constructor(sequence<u8> public_key, Network network);
    
    // Get string representation
    string to_string();
    
    // Get address type
    AddressType get_type();
    
    // Get network
    Network get_network();
    
    // Get script pubkey
    sequence<u8> get_script_pubkey();
};

// Address generator interface
interface AddressGenerator {
    // Create new generator
    constructor(Network network);
    
    // Generate address
    [Throws=KeyWalletError]
    Address generate(AccountXPub account_xpub, boolean external, u32 index);
    
    // Generate a range of addresses
    [Throws=KeyWalletError]
    sequence<Address> generate_range(AccountXPub account_xpub, boolean external, u32 start, u32 count);
};