/**
 * Key Wallet FFI - C Header File
 *
 * This header provides C-compatible function declarations for the key-wallet
 * Rust library FFI bindings.
 *
 * AUTO-GENERATED FILE - DO NOT EDIT
 * Generated using cbindgen
 */

#ifndef KEY_WALLET_FFI_H
#define KEY_WALLET_FFI_H

/* Generated with cbindgen:0.29.2 */

/* Warning: This file is auto-generated by cbindgen. Do not modify manually. */

#include <stdarg.h>
#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>
#include <stdlib.h>
#include <stdint.h>
#include <stddef.h>
#include <stdbool.h>

/*
 Account type enumeration matching all key_wallet AccountType variants

 This enum provides a complete FFI representation of all account types
 supported by the key_wallet library:

 - Standard accounts: BIP44 and BIP32 variants for regular transactions
 - CoinJoin: Privacy-enhanced transactions
 - Identity accounts: Registration, top-up, and invitation funding
 - Provider accounts: Various masternode provider key types (voting, owner, operator, platform)
 */
typedef enum {
    /*
     Standard BIP44 account (m/44'/coin_type'/account'/x/x)
     */
    STANDARD_BIP44 = 0,
    /*
     Standard BIP32 account (m/account'/x/x)
     */
    STANDARD_BIP32 = 1,
    /*
     CoinJoin account for private transactions
     */
    COIN_JOIN = 2,
    /*
     Identity registration funding
     */
    IDENTITY_REGISTRATION = 3,
    /*
     Identity top-up funding (requires registration_index)
     */
    IDENTITY_TOP_UP = 4,
    /*
     Identity top-up funding not bound to a specific identity
     */
    IDENTITY_TOP_UP_NOT_BOUND_TO_IDENTITY = 5,
    /*
     Identity invitation funding
     */
    IDENTITY_INVITATION = 6,
    /*
     Provider voting keys (DIP-3) - Path: m/9'/5'/3'/1'/\[key_index\]
     */
    PROVIDER_VOTING_KEYS = 7,
    /*
     Provider owner keys (DIP-3) - Path: m/9'/5'/3'/2'/\[key_index\]
     */
    PROVIDER_OWNER_KEYS = 8,
    /*
     Provider operator keys (DIP-3) - Path: m/9'/5'/3'/3'/\[key_index\]
     */
    PROVIDER_OPERATOR_KEYS = 9,
    /*
     Provider platform P2P keys (DIP-3, ED25519) - Path: m/9'/5'/3'/4'/\[key_index\]
     */
    PROVIDER_PLATFORM_KEYS = 10,
    /*
     DashPay incoming funds account using 256-bit derivation
     */
    DASHPAY_RECEIVING_FUNDS = 11,
    /*
     DashPay external (watch-only) account using 256-bit derivation
     */
    DASHPAY_EXTERNAL_ACCOUNT = 12,
    /*
     Platform Payment address (DIP-17) - Path: m/9'/5'/17'/account'/key_class'/index
     */
    PLATFORM_PAYMENT = 13,
} FFIAccountType;

/*
 FFI Network type (single network)
 */
typedef enum {
    DASH = 0,
    TESTNET = 1,
    REGTEST = 2,
    DEVNET = 3,
} FFINetwork;

/*
 FFI Error code
 */
typedef enum {
    SUCCESS = 0,
    INVALID_INPUT = 1,
    ALLOCATION_FAILED = 2,
    INVALID_MNEMONIC = 3,
    INVALID_DERIVATION_PATH = 4,
    INVALID_NETWORK = 5,
    INVALID_ADDRESS = 6,
    INVALID_TRANSACTION = 7,
    WALLET_ERROR = 8,
    SERIALIZATION_ERROR = 9,
    NOT_FOUND = 10,
    INVALID_STATE = 11,
    INTERNAL_ERROR = 12,
} FFIErrorCode;

/*
 Address pool type
 */
typedef enum {
    /*
     External (receive) addresses
     */
    EXTERNAL = 0,
    /*
     Internal (change) addresses
     */
    INTERNAL = 1,
    /*
     Single pool (for non-standard accounts)
     */
    SINGLE = 2,
} FFIAddressPoolType;

/*
 Language enumeration for mnemonic generation

 This enum must be kept in sync with key_wallet::mnemonic::Language.
 When adding new languages to the key_wallet crate, remember to update
 this FFI enum and both From implementations below.
 */
typedef enum {
    ENGLISH = 0,
    CHINESE_SIMPLIFIED = 1,
    CHINESE_TRADITIONAL = 2,
    CZECH = 3,
    FRENCH = 4,
    ITALIAN = 5,
    JAPANESE = 6,
    KOREAN = 7,
    PORTUGUESE = 8,
    SPANISH = 9,
} FFILanguage;

/*
 FFI-compatible transaction context
 */
typedef enum {
    /*
     Transaction is in the mempool (unconfirmed)
     */
    MEMPOOL = 0,
    /*
     Transaction is in a block at the given height
     */
    IN_BLOCK = 1,
    /*
     Transaction is in a chain-locked block at the given height
     */
    IN_CHAIN_LOCKED_BLOCK = 2,
} FFITransactionContext;

/*
 FFI Account Creation Option Type
 */
typedef enum {
    /*
     Create default accounts (BIP44 account 0, CoinJoin account 0, and special accounts)
     */
    DEFAULT = 0,
    /*
     Create all specified accounts plus all special purpose accounts
     */
    ALL_ACCOUNTS = 1,
    /*
     Create only BIP44 accounts (no CoinJoin or special accounts)
     */
    BIP44_ACCOUNTS_ONLY = 2,
    /*
     Create specific accounts with full control
     */
    SPECIFIC_ACCOUNTS = 3,
    /*
     Create no accounts at all
     */
    NO_ACCOUNTS = 4,
} FFIAccountCreationOptionType;

/*
 Opaque account handle
 */
typedef struct FFIAccount FFIAccount;

/*
 Opaque handle to an account collection
 */
typedef struct FFIAccountCollection FFIAccountCollection;

/*
 FFI wrapper for an AddressPool from a ManagedAccount

 This is a lightweight wrapper that holds a reference to an AddressPool
 from within a ManagedAccount. It allows querying addresses and pool information.
 */
typedef struct FFIAddressPool FFIAddressPool;

/*
 Opaque BLS account handle
 */
typedef struct FFIBLSAccount FFIBLSAccount;

/*
 Opaque EdDSA account handle
 */
typedef struct FFIEdDSAAccount FFIEdDSAAccount;

/*
 Extended private key structure
 */
typedef struct FFIExtendedPrivKey FFIExtendedPrivKey;

/*
 Opaque type for an extended private key
 */
typedef struct FFIExtendedPrivateKey FFIExtendedPrivateKey;

/*
 Extended public key structure
 */
typedef struct FFIExtendedPubKey FFIExtendedPubKey;

/*
 Opaque type for an extended public key
 */
typedef struct FFIExtendedPublicKey FFIExtendedPublicKey;

/*
 Opaque managed account handle that wraps ManagedAccount
 */
typedef struct FFIManagedAccount FFIManagedAccount;

/*
 Opaque handle to a managed account collection
 */
typedef struct FFIManagedAccountCollection FFIManagedAccountCollection;

/*
 Opaque managed platform account handle that wraps ManagedPlatformAccount

 This is different from FFIManagedAccount because ManagedPlatformAccount
 has a different structure optimized for Platform Payment accounts (DIP-17):
 - Simple u64 credit balance instead of WalletCoreBalance
 - Per-address balances tracked directly
 - No transactions or UTXOs (Platform handles these)
 */
typedef struct FFIManagedPlatformAccount FFIManagedPlatformAccount;

/*
 Opaque type for a private key (SecretKey)
 */
typedef struct FFIPrivateKey FFIPrivateKey;

/*
 Opaque type for a public key
 */
typedef struct FFIPublicKey FFIPublicKey;

/*
 Opaque handle for a transaction
 */
typedef struct FFITransaction FFITransaction;

/*
 Opaque wallet handle
 */
typedef struct FFIWallet FFIWallet;

/*
 FFI wrapper for WalletManager

 This struct holds a cloned Arc reference to the WalletManager,
 allowing FFI code to interact with it directly without going through
 the SPV client.
 */
typedef struct FFIWalletManager FFIWalletManager;

/*
 FFI Result type for Account operations
 */
typedef struct {
    /*
     The account handle if successful, NULL if error
     */
    FFIAccount *account;
    /*
     Error code (0 = success)
     */
    int32_t error_code;
    /*
     Error message (NULL if success, must be freed by caller if not NULL)
     */
    char *error_message;
} FFIAccountResult;

/*
 FFI Error structure
 */
typedef struct {
    FFIErrorCode code;
    char *message;
} FFIError;

/*
 C-compatible summary of all accounts in a collection

 This struct provides Swift with structured data about all accounts
 that exist in the collection, allowing programmatic access to account
 indices and presence information.
 */
typedef struct {
    /*
     Array of BIP44 account indices
     */
    unsigned int *bip44_indices;
    /*
     Number of BIP44 accounts
     */
    size_t bip44_count;
    /*
     Array of BIP32 account indices
     */
    unsigned int *bip32_indices;
    /*
     Number of BIP32 accounts
     */
    size_t bip32_count;
    /*
     Array of CoinJoin account indices
     */
    unsigned int *coinjoin_indices;
    /*
     Number of CoinJoin accounts
     */
    size_t coinjoin_count;
    /*
     Array of identity top-up registration indices
     */
    unsigned int *identity_topup_indices;
    /*
     Number of identity top-up accounts
     */
    size_t identity_topup_count;
    /*
     Whether identity registration account exists
     */
    bool has_identity_registration;
    /*
     Whether identity invitation account exists
     */
    bool has_identity_invitation;
    /*
     Whether identity top-up not bound account exists
     */
    bool has_identity_topup_not_bound;
    /*
     Whether provider voting keys account exists
     */
    bool has_provider_voting_keys;
    /*
     Whether provider owner keys account exists
     */
    bool has_provider_owner_keys;
    /*
     Whether provider operator keys account exists
     */
    bool has_provider_operator_keys;
    /*
     Whether provider platform keys account exists
     */
    bool has_provider_platform_keys;
} FFIAccountCollectionSummary;

/*
 FFI wrapper for ManagedWalletInfo (single canonical type)
 */
typedef struct {
    void *inner;
} FFIManagedWalletInfo;

/*
 Address pool info
 */
typedef struct {
    /*
     Pool type
     */
    FFIAddressPoolType pool_type;
    /*
     Number of generated addresses
     */
    unsigned int generated_count;
    /*
     Number of used addresses
     */
    unsigned int used_count;
    /*
     Current gap (unused addresses at the end)
     */
    unsigned int current_gap;
    /*
     Gap limit setting
     */
    unsigned int gap_limit;
    /*
     Highest used index (-1 if none used)
     */
    int32_t highest_used_index;
} FFIAddressPoolInfo;

/*
 FFI-compatible version of AddressInfo
 */
typedef struct {
    /*
     Address as string
     */
    char *address;
    /*
     Script pubkey bytes
     */
    uint8_t *script_pubkey;
    /*
     Length of script pubkey
     */
    size_t script_pubkey_len;
    /*
     Public key bytes (nullable)
     */
    uint8_t *public_key;
    /*
     Length of public key
     */
    size_t public_key_len;
    /*
     Derivation index
     */
    uint32_t index;
    /*
     Derivation path as string
     */
    char *path;
    /*
     Whether address has been used
     */
    bool used;
    /*
     When generated (timestamp)
     */
    uint64_t generated_at;
    /*
     When first used (0 if never)
     */
    uint64_t used_at;
    /*
     Transaction count
     */
    uint32_t tx_count;
    /*
     Total received
     */
    uint64_t total_received;
    /*
     Total sent
     */
    uint64_t total_sent;
    /*
     Current balance
     */
    uint64_t balance;
    /*
     Custom label (nullable)
     */
    char *label;
} FFIAddressInfo;

/*
 FFI Result type for ManagedAccount operations
 */
typedef struct {
    /*
     The managed account handle if successful, NULL if error
     */
    FFIManagedAccount *account;
    /*
     Error code (0 = success)
     */
    int32_t error_code;
    /*
     Error message (NULL if success, must be freed by caller if not NULL)
     */
    char *error_message;
} FFIManagedAccountResult;

/*
 FFI Balance type for representing wallet balances
 */
typedef struct {
    /*
     Confirmed balance in duffs
     */
    uint64_t confirmed;
    /*
     Unconfirmed balance in duffs
     */
    uint64_t unconfirmed;
    /*
     Immature balance in duffs (e.g., mining rewards not yet mature)
     */
    uint64_t immature;
    /*
     Locked balance in duffs (e.g., CoinJoin reserves)
     */
    uint64_t locked;
    /*
     Total balance in duffs
     */
    uint64_t total;
} FFIBalance;

/*
 FFI-compatible transaction record
 */
typedef struct {
    /*
     Transaction ID (32 bytes)
     */
    uint8_t txid[32];
    /*
     Net amount for this account (positive = received, negative = sent)
     */
    int64_t net_amount;
    /*
     Block height if confirmed, 0 if unconfirmed
     */
    uint32_t height;
    /*
     Block hash if confirmed (32 bytes), all zeros if unconfirmed
     */
    uint8_t block_hash[32];
    /*
     Unix timestamp
     */
    uint64_t timestamp;
    /*
     Fee if known, 0 if unknown
     */
    uint64_t fee;
    /*
     Whether this is our transaction
     */
    bool is_ours;
} FFITransactionRecord;

/*
 FFI Result type for ManagedPlatformAccount operations
 */
typedef struct {
    /*
     The managed platform account handle if successful, NULL if error
     */
    FFIManagedPlatformAccount *account;
    /*
     Error code (0 = success)
     */
    int32_t error_code;
    /*
     Error message (NULL if success, must be freed by caller if not NULL)
     */
    char *error_message;
} FFIManagedPlatformAccountResult;

/*
 C-compatible platform payment account key
 */
typedef struct {
    /*
     Account index (hardened)
     */
    unsigned int account;
    /*
     Key class (hardened)
     */
    unsigned int key_class;
} FFIPlatformPaymentAccountKey;

/*
 C-compatible summary of all accounts in a managed collection

 This struct provides Swift with structured data about all accounts
 that exist in the managed collection, allowing programmatic access to account
 indices and presence information.
 */
typedef struct {
    /*
     Array of BIP44 account indices
     */
    unsigned int *bip44_indices;
    /*
     Number of BIP44 accounts
     */
    size_t bip44_count;
    /*
     Array of BIP32 account indices
     */
    unsigned int *bip32_indices;
    /*
     Number of BIP32 accounts
     */
    size_t bip32_count;
    /*
     Array of CoinJoin account indices
     */
    unsigned int *coinjoin_indices;
    /*
     Number of CoinJoin accounts
     */
    size_t coinjoin_count;
    /*
     Array of identity top-up registration indices
     */
    unsigned int *identity_topup_indices;
    /*
     Number of identity top-up accounts
     */
    size_t identity_topup_count;
    /*
     Whether identity registration account exists
     */
    bool has_identity_registration;
    /*
     Whether identity invitation account exists
     */
    bool has_identity_invitation;
    /*
     Whether identity top-up not bound account exists
     */
    bool has_identity_topup_not_bound;
    /*
     Whether provider voting keys account exists
     */
    bool has_provider_voting_keys;
    /*
     Whether provider owner keys account exists
     */
    bool has_provider_owner_keys;
    /*
     Whether provider operator keys account exists
     */
    bool has_provider_operator_keys;
    /*
     Whether provider platform keys account exists
     */
    bool has_provider_platform_keys;
    /*
     Array of Platform Payment account keys (account, key_class pairs)
     */
    FFIPlatformPaymentAccountKey *platform_payment_keys;
    /*
     Number of Platform Payment accounts
     */
    size_t platform_payment_count;
} FFIManagedAccountCollectionSummary;

/*
 Transaction output for building (legacy structure)
 */
typedef struct {
    const char *address;
    uint64_t amount;
} FFITxOutput;

/*
 Transaction check result
 */
typedef struct {
    /*
     Whether the transaction belongs to the wallet
     */
    bool is_relevant;
    /*
     Total amount received
     */
    uint64_t total_received;
    /*
     Total amount sent
     */
    uint64_t total_sent;
    /*
     Number of affected accounts
     */
    uint32_t affected_accounts_count;
} FFITransactionCheckResult;

/*
 FFI-compatible transaction input
 */
typedef struct {
    /*
     Transaction ID (32 bytes)
     */
    uint8_t txid[32];
    /*
     Output index
     */
    uint32_t vout;
    /*
     Script signature length
     */
    uint32_t script_sig_len;
    /*
     Script signature data pointer
     */
    const uint8_t *script_sig;
    /*
     Sequence number
     */
    uint32_t sequence;
} FFITxIn;

/*
 FFI-compatible transaction output
 */
typedef struct {
    /*
     Amount in duffs
     */
    uint64_t amount;
    /*
     Script pubkey length
     */
    uint32_t script_pubkey_len;
    /*
     Script pubkey data pointer
     */
    const uint8_t *script_pubkey;
} FFITxOut;

/*
 UTXO structure for FFI
 */
typedef struct {
    uint8_t txid[32];
    uint32_t vout;
    uint64_t amount;
    char *address;
    uint8_t *script_pubkey;
    size_t script_len;
    uint32_t height;
    uint32_t confirmations;
} FFIUTXO;

/*
 FFI specification for a PlatformPayment account to create

 PlatformPayment accounts (DIP-17) use the derivation path:
 `m/9'/coin_type'/17'/account'/key_class'/index`
 */
typedef struct {
    /*
     Account index (hardened) - the account' level in the derivation path
     */
    uint32_t account;
    /*
     Key class (hardened) - defaults to 0', 1' is reserved for change-like segregation
     */
    uint32_t key_class;
} FFIPlatformPaymentAccountSpec;

/*
 FFI structure for wallet account creation options
 This single struct represents all possible account creation configurations
 */
typedef struct {
    /*
     The type of account creation option
     */
    FFIAccountCreationOptionType option_type;
    /*
     Array of BIP44 account indices to create
     */
    const uint32_t *bip44_indices;
    size_t bip44_count;
    /*
     Array of BIP32 account indices to create
     */
    const uint32_t *bip32_indices;
    size_t bip32_count;
    /*
     Array of CoinJoin account indices to create
     */
    const uint32_t *coinjoin_indices;
    size_t coinjoin_count;
    /*
     Array of identity top-up registration indices to create
     */
    const uint32_t *topup_indices;
    size_t topup_count;
    /*
     Array of PlatformPayment account specs to create
     */
    const FFIPlatformPaymentAccountSpec *platform_payment_specs;
    size_t platform_payment_count;
    /*
     For SpecificAccounts: Additional special account types to create
     (e.g., IdentityRegistration, ProviderKeys, etc.)
     This is an array of FFIAccountType values
     */
    const FFIAccountType *special_account_types;
    size_t special_account_types_count;
} FFIWalletAccountCreationOptions;

/*
 FFI-compatible transaction context details
 */
typedef struct {
    /*
     The context type
     */
    FFITransactionContext context_type;
    /*
     Block height (0 for mempool)
     */
    unsigned int height;
    /*
     Block hash (32 bytes, null for mempool or if unknown)
     */
    const uint8_t *block_hash;
    /*
     Timestamp (0 if unknown)
     */
    unsigned int timestamp;
} FFITransactionContextDetails;

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

/*
 Initialize the library
 */
 bool key_wallet_ffi_initialize(void) ;

/*
 Get library version

 Returns a static string that should NOT be freed by the caller
 */
 const char *key_wallet_ffi_version(void) ;

/*
 Get an account handle for a specific account type
 Returns a result containing either the account handle or an error

 # Safety

 - `wallet` must be a valid pointer to an FFIWallet instance
 - The caller must ensure the wallet pointer remains valid for the duration of this call
 */

FFIAccountResult wallet_get_account(const FFIWallet *wallet,
                                    unsigned int account_index,
                                    FFIAccountType account_type)
;

/*
 Get an IdentityTopUp account handle with a specific registration index
 This is used for top-up accounts that are bound to a specific identity
 Returns a result containing either the account handle or an error

 # Safety

 - `wallet` must be a valid pointer to an FFIWallet instance
 - The caller must ensure the wallet pointer remains valid for the duration of this call
 */

FFIAccountResult wallet_get_top_up_account_with_registration_index(const FFIWallet *wallet,
                                                                   unsigned int registration_index)
;

/*
 Free an account handle

 # Safety

 - `account` must be a valid pointer to an FFIAccount that was allocated by this library
 - The pointer must not be used after calling this function
 - This function must only be called once per allocation
 */
 void account_free(FFIAccount *account) ;

/*
 Free a BLS account handle

 # Safety

 - `account` must be a valid pointer to an FFIBLSAccount
 - The pointer must not be used after calling this function
 - This function must only be called once per allocation
 */
 void bls_account_free(FFIBLSAccount *account) ;

/*
 Free an EdDSA account handle

 # Safety

 - `account` must be a valid pointer to an FFIEdDSAAccount
 - The pointer must not be used after calling this function
 - This function must only be called once per allocation
 */
 void eddsa_account_free(FFIEdDSAAccount *account) ;

/*
 Free an account result's error message (if any)
 Note: This does NOT free the account handle itself - use account_free for that

 # Safety

 - `result` must be a valid pointer to an FFIAccountResult
 - The error_message field must be either null or a valid CString allocated by this library
 - The caller must ensure the result pointer remains valid for the duration of this call
 */
 void account_result_free_error(FFIAccountResult *result) ;

/*
 Get the extended public key of an account as a string

 # Safety

 - `account` must be a valid pointer to an FFIAccount instance
 - The returned string must be freed by the caller using `string_free`
 - Returns NULL if the account is null
 */
 char *account_get_extended_public_key_as_string(const FFIAccount *account) ;

/*
 Get the network of an account

 # Safety

 - `account` must be a valid pointer to an FFIAccount instance
 - Returns `FFINetwork::Dash` if the account is null
 */
 FFINetwork account_get_network(const FFIAccount *account) ;

/*
 Get the parent wallet ID of an account

 # Safety

 - `account` must be a valid pointer to an FFIAccount instance
 - Returns a pointer to the 32-byte wallet ID, or NULL if not set or account is null
 - The returned pointer is valid only as long as the account exists
 - The caller should copy the data if needed for longer use
 */
 const uint8_t *account_get_parent_wallet_id(const FFIAccount *account) ;

/*
 Get the account type of an account

 # Safety

 - `account` must be a valid pointer to an FFIAccount instance
 - `out_index` must be a valid pointer to a c_uint where the index will be stored
 - Returns FFIAccountType::StandardBIP44 with index 0 if the account is null
 */
 FFIAccountType account_get_account_type(const FFIAccount *account, unsigned int *out_index) ;

/*
 Check if an account is watch-only

 # Safety

 - `account` must be a valid pointer to an FFIAccount instance
 - Returns false if the account is null
 */
 bool account_get_is_watch_only(const FFIAccount *account) ;

/*
 Get the extended public key of a BLS account as a string

 # Safety

 - `account` must be a valid pointer to an FFIBLSAccount instance
 - The returned string must be freed by the caller using `string_free`
 - Returns NULL if the account is null
 */
 char *bls_account_get_extended_public_key_as_string(const FFIBLSAccount *account) ;

/*
 Get the network of a BLS account

 # Safety

 - `account` must be a valid pointer to an FFIBLSAccount instance
 - Returns `FFINetwork::Dash` if the account is null
 */
 FFINetwork bls_account_get_network(const FFIBLSAccount *account) ;

/*
 Get the parent wallet ID of a BLS account

 # Safety

 - `account` must be a valid pointer to an FFIBLSAccount instance
 - Returns a pointer to the 32-byte wallet ID, or NULL if not set or account is null
 - The returned pointer is valid only as long as the account exists
 - The caller should copy the data if needed for longer use
 */
 const uint8_t *bls_account_get_parent_wallet_id(const FFIBLSAccount *account) ;

/*
 Get the account type of a BLS account

 # Safety

 - `account` must be a valid pointer to an FFIBLSAccount instance
 - `out_index` must be a valid pointer to a c_uint where the index will be stored
 - Returns FFIAccountType::StandardBIP44 with index 0 if the account is null
 */

FFIAccountType bls_account_get_account_type(const FFIBLSAccount *account,
                                            unsigned int *out_index)
;

/*
 Check if a BLS account is watch-only

 # Safety

 - `account` must be a valid pointer to an FFIBLSAccount instance
 - Returns false if the account is null
 */
 bool bls_account_get_is_watch_only(const FFIBLSAccount *account) ;

/*
 Get the extended public key of an EdDSA account as a string

 # Safety

 - `account` must be a valid pointer to an FFIEdDSAAccount instance
 - The returned string must be freed by the caller using `string_free`
 - Returns NULL if the account is null
 */
 char *eddsa_account_get_extended_public_key_as_string(const FFIEdDSAAccount *account) ;

/*
 Get the network of an EdDSA account

 # Safety

 - `account` must be a valid pointer to an FFIEdDSAAccount instance
 - Returns `FFINetwork::Dash` if the account is null
 */
 FFINetwork eddsa_account_get_network(const FFIEdDSAAccount *account) ;

/*
 Get the parent wallet ID of an EdDSA account

 # Safety

 - `account` must be a valid pointer to an FFIEdDSAAccount instance
 - Returns a pointer to the 32-byte wallet ID, or NULL if not set or account is null
 - The returned pointer is valid only as long as the account exists
 - The caller should copy the data if needed for longer use
 */
 const uint8_t *eddsa_account_get_parent_wallet_id(const FFIEdDSAAccount *account) ;

/*
 Get the account type of an EdDSA account

 # Safety

 - `account` must be a valid pointer to an FFIEdDSAAccount instance
 - `out_index` must be a valid pointer to a c_uint where the index will be stored
 - Returns FFIAccountType::StandardBIP44 with index 0 if the account is null
 */

FFIAccountType eddsa_account_get_account_type(const FFIEdDSAAccount *account,
                                              unsigned int *out_index)
;

/*
 Check if an EdDSA account is watch-only

 # Safety

 - `account` must be a valid pointer to an FFIEdDSAAccount instance
 - Returns false if the account is null
 */
 bool eddsa_account_get_is_watch_only(const FFIEdDSAAccount *account) ;

/*
 Get number of accounts

 # Safety

 - `wallet` must be a valid pointer to an FFIWallet instance
 - `error` must be a valid pointer to an FFIError structure or null
 - The caller must ensure both pointers remain valid for the duration of this call
 */
 unsigned int wallet_get_account_count(const FFIWallet *wallet, FFIError *error) ;

/*
 Get account collection for a specific network from wallet

 # Safety

 - `wallet` must be a valid pointer to an FFIWallet instance
 - `error` must be a valid pointer to an FFIError structure or null
 - The returned pointer must be freed with `account_collection_free` when no longer needed
 */
 FFIAccountCollection *wallet_get_account_collection(const FFIWallet *wallet, FFIError *error) ;

/*
 Free an account collection handle

 # Safety

 - `collection` must be a valid pointer to an FFIAccountCollection created by this library
 - `collection` must not be used after calling this function
 */
 void account_collection_free(FFIAccountCollection *collection) ;

/*
 Get a BIP44 account by index from the collection

 # Safety

 - `collection` must be a valid pointer to an FFIAccountCollection
 - The returned pointer must be freed with `account_free` when no longer needed
 */

FFIAccount *account_collection_get_bip44_account(const FFIAccountCollection *collection,
                                                 unsigned int index)
;

/*
 Get all BIP44 account indices

 # Safety

 - `collection` must be a valid pointer to an FFIAccountCollection
 - `out_indices` must be a valid pointer to store the indices array
 - `out_count` must be a valid pointer to store the count
 - The returned array must be freed with `free_u32_array` when no longer needed
 */

bool account_collection_get_bip44_indices(const FFIAccountCollection *collection,
                                          unsigned int **out_indices,
                                          size_t *out_count)
;

/*
 Get a BIP32 account by index from the collection

 # Safety

 - `collection` must be a valid pointer to an FFIAccountCollection
 - The returned pointer must be freed with `account_free` when no longer needed
 */

FFIAccount *account_collection_get_bip32_account(const FFIAccountCollection *collection,
                                                 unsigned int index)
;

/*
 Get all BIP32 account indices

 # Safety

 - `collection` must be a valid pointer to an FFIAccountCollection
 - `out_indices` must be a valid pointer to store the indices array
 - `out_count` must be a valid pointer to store the count
 - The returned array must be freed with `free_u32_array` when no longer needed
 */

bool account_collection_get_bip32_indices(const FFIAccountCollection *collection,
                                          unsigned int **out_indices,
                                          size_t *out_count)
;

/*
 Get a CoinJoin account by index from the collection

 # Safety

 - `collection` must be a valid pointer to an FFIAccountCollection
 - The returned pointer must be freed with `account_free` when no longer needed
 */

FFIAccount *account_collection_get_coinjoin_account(const FFIAccountCollection *collection,
                                                    unsigned int index)
;

/*
 Get all CoinJoin account indices

 # Safety

 - `collection` must be a valid pointer to an FFIAccountCollection
 - `out_indices` must be a valid pointer to store the indices array
 - `out_count` must be a valid pointer to store the count
 - The returned array must be freed with `free_u32_array` when no longer needed
 */

bool account_collection_get_coinjoin_indices(const FFIAccountCollection *collection,
                                             unsigned int **out_indices,
                                             size_t *out_count)
;

/*
 Get the identity registration account if it exists

 # Safety

 - `collection` must be a valid pointer to an FFIAccountCollection
 - The returned pointer must be freed with `account_free` when no longer needed
 */
 FFIAccount *account_collection_get_identity_registration(const FFIAccountCollection *collection) ;

/*
 Check if identity registration account exists

 # Safety

 - `collection` must be a valid pointer to an FFIAccountCollection
 */
 bool account_collection_has_identity_registration(const FFIAccountCollection *collection) ;

/*
 Get an identity topup account by registration index

 # Safety

 - `collection` must be a valid pointer to an FFIAccountCollection
 - The returned pointer must be freed with `account_free` when no longer needed
 */

FFIAccount *account_collection_get_identity_topup(const FFIAccountCollection *collection,
                                                  unsigned int registration_index)
;

/*
 Get all identity topup registration indices

 # Safety

 - `collection` must be a valid pointer to an FFIAccountCollection
 - `out_indices` must be a valid pointer to store the indices array
 - `out_count` must be a valid pointer to store the count
 - The returned array must be freed with `free_u32_array` when no longer needed
 */

bool account_collection_get_identity_topup_indices(const FFIAccountCollection *collection,
                                                   unsigned int **out_indices,
                                                   size_t *out_count)
;

/*
 Get the identity topup not bound account if it exists

 # Safety

 - `collection` must be a valid pointer to an FFIAccountCollection
 - The returned pointer must be freed with `account_free` when no longer needed
 */

FFIAccount *account_collection_get_identity_topup_not_bound(const FFIAccountCollection *collection)
;

/*
 Check if identity topup not bound account exists

 # Safety

 - `collection` must be a valid pointer to an FFIAccountCollection
 */
 bool account_collection_has_identity_topup_not_bound(const FFIAccountCollection *collection) ;

/*
 Get the identity invitation account if it exists

 # Safety

 - `collection` must be a valid pointer to an FFIAccountCollection
 - The returned pointer must be freed with `account_free` when no longer needed
 */
 FFIAccount *account_collection_get_identity_invitation(const FFIAccountCollection *collection) ;

/*
 Check if identity invitation account exists

 # Safety

 - `collection` must be a valid pointer to an FFIAccountCollection
 */
 bool account_collection_has_identity_invitation(const FFIAccountCollection *collection) ;

/*
 Get the provider voting keys account if it exists

 # Safety

 - `collection` must be a valid pointer to an FFIAccountCollection
 - The returned pointer must be freed with `account_free` when no longer needed
 */
 FFIAccount *account_collection_get_provider_voting_keys(const FFIAccountCollection *collection) ;

/*
 Check if provider voting keys account exists

 # Safety

 - `collection` must be a valid pointer to an FFIAccountCollection
 */
 bool account_collection_has_provider_voting_keys(const FFIAccountCollection *collection) ;

/*
 Get the provider owner keys account if it exists

 # Safety

 - `collection` must be a valid pointer to an FFIAccountCollection
 - The returned pointer must be freed with `account_free` when no longer needed
 */
 FFIAccount *account_collection_get_provider_owner_keys(const FFIAccountCollection *collection) ;

/*
 Check if provider owner keys account exists

 # Safety

 - `collection` must be a valid pointer to an FFIAccountCollection
 */
 bool account_collection_has_provider_owner_keys(const FFIAccountCollection *collection) ;

/*
 Get the provider operator keys account if it exists
 Note: Returns null if the `bls` feature is not enabled

 # Safety

 - `collection` must be a valid pointer to an FFIAccountCollection
 - The returned pointer must be freed with `bls_account_free` when no longer needed (when BLS is enabled)
 */

void *account_collection_get_provider_operator_keys(const FFIAccountCollection *collection)
;

/*
 Check if provider operator keys account exists

 # Safety

 - `collection` must be a valid pointer to an FFIAccountCollection
 */
 bool account_collection_has_provider_operator_keys(const FFIAccountCollection *collection) ;

/*
 Get the provider platform keys account if it exists
 Note: Returns null if the `eddsa` feature is not enabled

 # Safety

 - `collection` must be a valid pointer to an FFIAccountCollection
 - The returned pointer must be freed with `eddsa_account_free` when no longer needed (when EdDSA is enabled)
 */

void *account_collection_get_provider_platform_keys(const FFIAccountCollection *collection)
;

/*
 Check if provider platform keys account exists

 # Safety

 - `collection` must be a valid pointer to an FFIAccountCollection
 */
 bool account_collection_has_provider_platform_keys(const FFIAccountCollection *collection) ;

/*
 Free a u32 array allocated by this library

 # Safety

 - `array` must be a valid pointer to an array allocated by this library
 - `array` must not be used after calling this function
 */
 void free_u32_array(unsigned int *array, size_t count) ;

/*
 Get the total number of accounts in the collection

 # Safety

 - `collection` must be a valid pointer to an FFIAccountCollection
 */
 unsigned int account_collection_count(const FFIAccountCollection *collection) ;

/*
 Get a human-readable summary of all accounts in the collection

 Returns a formatted string showing all account types and their indices.
 The format is designed to be clear and readable for end users.

 # Safety

 - `collection` must be a valid pointer to an FFIAccountCollection
 - The returned string must be freed with `string_free` when no longer needed
 - Returns null if the collection pointer is null
 */
 char *account_collection_summary(const FFIAccountCollection *collection) ;

/*
 Get structured account collection summary data

 Returns a struct containing arrays of indices for each account type and boolean
 flags for special accounts. This provides Swift with programmatic access to
 account information.

 # Safety

 - `collection` must be a valid pointer to an FFIAccountCollection
 - The returned pointer must be freed with `account_collection_summary_free` when no longer needed
 - Returns null if the collection pointer is null
 */

FFIAccountCollectionSummary *account_collection_summary_data(const FFIAccountCollection *collection)
;

/*
 Free an account collection summary and all its allocated memory

 # Safety

 - `summary` must be a valid pointer to an FFIAccountCollectionSummary created by `account_collection_summary_data`
 - `summary` must not be used after calling this function
 */

void account_collection_summary_free(FFIAccountCollectionSummary *summary)
;

/*
 Derive an extended private key from an account at a given index, using the provided master xpriv.

 Returns an opaque FFIExtendedPrivateKey pointer that must be freed with `extended_private_key_free`.

 Notes:
 - This is chain-agnostic. For accounts with internal/external chains, this returns an error.
 - For hardened-only account types (e.g., EdDSA), a hardened index is used.

 # Safety
 - `account` and `master_xpriv` must be valid, non-null pointers allocated by this library.
 - `error` must be a valid pointer to an FFIError or null.
 - The caller must free the returned pointer with `extended_private_key_free`.
 */

FFIExtendedPrivateKey *account_derive_extended_private_key_at(const FFIAccount *account,
                                                              const FFIExtendedPrivateKey *master_xpriv,
                                                              unsigned int index,
                                                              FFIError *error)
;

/*
 Derive a BLS private key from a raw seed buffer at the given index.

 Returns a newly allocated hex string of the 32-byte private key. The caller must free
 it with `string_free`.

 Notes:
 - Uses the account's network for master key creation.
 - Chain-agnostic; may return an error for accounts with internal/external chains.

 # Safety
 - `account` must be a valid, non-null pointer to an `FFIBLSAccount` (only when `bls` feature is enabled).
 - `seed` must point to a readable buffer of length `seed_len` (1..=64 bytes expected).
 - `error` must be a valid pointer to an FFIError or null.
 - Returned string must be freed with `string_free`.
 */

char *bls_account_derive_private_key_from_seed(const FFIBLSAccount *account,
                                               const uint8_t *seed,
                                               size_t seed_len,
                                               unsigned int index,
                                               FFIError *error)
;

/*
 Derive a BLS private key from a mnemonic + optional passphrase at the given index.

 Returns a newly allocated hex string of the 32-byte private key. The caller must free
 it with `string_free`.

 Notes:
 - Uses the English wordlist for parsing the mnemonic.
 - Chain-agnostic; may return an error for accounts with internal/external chains.

 # Safety
 - `account` must be a valid, non-null pointer to an `FFIBLSAccount` (only when `bls` feature is enabled).
 - `mnemonic` must be a valid, null-terminated UTF-8 C string.
 - `passphrase` may be null; if not null, must be a valid UTF-8 C string.
 - `error` must be a valid pointer to an FFIError or null.
 - Returned string must be freed with `string_free`.
 */

char *bls_account_derive_private_key_from_mnemonic(const FFIBLSAccount *account,
                                                   const char *mnemonic,
                                                   const char *passphrase,
                                                   unsigned int index,
                                                   FFIError *error)
;

/*
 Derive an EdDSA (ed25519) private key from a raw seed buffer at the given index.

 Returns a newly allocated hex string of the 32-byte private key. The caller must free
 it with `string_free`.

 Notes:
 - EdDSA only supports hardened derivation; the index will be used accordingly.
 - Chain-agnostic; EdDSA accounts typically do not have internal/external split.

 # Safety
 - `account` must be a valid, non-null pointer to an `FFIEdDSAAccount` (only when `eddsa` feature is enabled).
 - `seed` must point to a readable buffer of length `seed_len` (1..=64 bytes expected).
 - `error` must be a valid pointer to an FFIError or null.
 - Returned string must be freed with `string_free`.
 */

char *eddsa_account_derive_private_key_from_seed(const FFIEdDSAAccount *account,
                                                 const uint8_t *seed,
                                                 size_t seed_len,
                                                 unsigned int index,
                                                 FFIError *error)
;

/*
 Derive an EdDSA (ed25519) private key from a mnemonic + optional passphrase at the given index.

 Returns a newly allocated hex string of the 32-byte private key. The caller must free
 it with `string_free`.

 Notes:
 - Uses the English wordlist for parsing the mnemonic.

 # Safety
 - `account` must be a valid, non-null pointer to an `FFIEdDSAAccount` (only when `eddsa` feature is enabled).
 - `mnemonic` must be a valid, null-terminated UTF-8 C string.
 - `passphrase` may be null; if not null, must be a valid UTF-8 C string.
 - `error` must be a valid pointer to an FFIError or null.
 - Returned string must be freed with `string_free`.
 */

char *eddsa_account_derive_private_key_from_mnemonic(const FFIEdDSAAccount *account,
                                                     const char *mnemonic,
                                                     const char *passphrase,
                                                     unsigned int index,
                                                     FFIError *error)
;

/*
 Derive a private key (secp256k1) from an account at a given chain/index, using the provided master xpriv.
 Returns an opaque FFIPrivateKey pointer that must be freed with `private_key_free`.

 # Safety
 - `account` and `master_xpriv` must be valid pointers allocated by this library
 - `error` must be a valid pointer to an FFIError or null
 */

FFIPrivateKey *account_derive_private_key_at(const FFIAccount *account,
                                             const FFIExtendedPrivateKey *master_xpriv,
                                             unsigned int index,
                                             FFIError *error)
;

/*
 Derive a private key from an account at a given chain/index and return as WIF string.
 Caller must free the returned string with `string_free`.

 # Safety
 - `account` and `master_xpriv` must be valid pointers allocated by this library
 - `error` must be a valid pointer to an FFIError or null
 */

char *account_derive_private_key_as_wif_at(const FFIAccount *account,
                                           const FFIExtendedPrivateKey *master_xpriv,
                                           unsigned int index,
                                           FFIError *error)
;

/*
 Derive an extended private key from a raw seed buffer at the given index.
 Returns an opaque FFIExtendedPrivateKey pointer that must be freed with `extended_private_key_free`.

 # Safety
 - `account` must be a valid pointer to an FFIAccount
 - `seed` must point to a valid buffer of length `seed_len`
 - `error` must be a valid pointer to an FFIError or null
 */

FFIExtendedPrivateKey *account_derive_extended_private_key_from_seed(const FFIAccount *account,
                                                                     const uint8_t *seed,
                                                                     size_t seed_len,
                                                                     unsigned int index,
                                                                     FFIError *error)
;

/*
 Derive a private key from a raw seed buffer at the given index.
 Returns an opaque FFIPrivateKey pointer that must be freed with `private_key_free`.

 # Safety
 - `account` must be a valid pointer to an FFIAccount
 - `seed` must point to a valid buffer of length `seed_len`
 - `error` must be a valid pointer to an FFIError or null
 */

FFIPrivateKey *account_derive_private_key_from_seed(const FFIAccount *account,
                                                    const uint8_t *seed,
                                                    size_t seed_len,
                                                    unsigned int index,
                                                    FFIError *error)
;

/*
 Derive an extended private key from a mnemonic + optional passphrase at the given index.
 Returns an opaque FFIExtendedPrivateKey pointer that must be freed with `extended_private_key_free`.

 # Safety
 - `account` must be a valid pointer to an FFIAccount
 - `mnemonic` must be a valid, null-terminated C string
 - `passphrase` may be null; if not null, must be a valid C string
 - `error` must be a valid pointer to an FFIError or null
 */

FFIExtendedPrivateKey *account_derive_extended_private_key_from_mnemonic(const FFIAccount *account,
                                                                         const char *mnemonic,
                                                                         const char *passphrase,
                                                                         unsigned int index,
                                                                         FFIError *error)
;

/*
 Derive a private key from a mnemonic + optional passphrase at the given index.
 Returns an opaque FFIPrivateKey pointer that must be freed with `private_key_free`.

 # Safety
 - `account` must be a valid pointer to an FFIAccount
 - `mnemonic` must be a valid, null-terminated C string
 - `passphrase` may be null; if not null, must be a valid C string
 - `error` must be a valid pointer to an FFIError or null
 */

FFIPrivateKey *account_derive_private_key_from_mnemonic(const FFIAccount *account,
                                                        const char *mnemonic,
                                                        const char *passphrase,
                                                        unsigned int index,
                                                        FFIError *error)
;

/*
 Free address string

 # Safety

 - `address` must be a valid pointer created by address functions or null
 - After calling this function, the pointer becomes invalid
 */
 void address_free(char *address) ;

/*
 Free address array

 # Safety

 - `addresses` must be a valid pointer to an array of address strings or null
 - Each address in the array must be a valid C string pointer
 - `count` must be the correct number of addresses in the array
 - After calling this function, all pointers become invalid
 */
 void address_array_free(char **addresses, size_t count) ;

/*
 Validate an address

 # Safety

 - `address` must be a valid null-terminated C string
 - `error` must be a valid pointer to an FFIError
 */
 bool address_validate(const char *address, FFINetwork network, FFIError *error) ;

/*
 Get address type

 Returns:
 - 0: P2PKH address
 - 1: P2SH address
 - 2: Other address type
 - u8::MAX (255): Error occurred

 # Safety

 - `address` must be a valid null-terminated C string
 - `error` must be a valid pointer to an FFIError
 */
 unsigned char address_get_type(const char *address, FFINetwork network, FFIError *error) ;

/*
 Free an address pool handle

 # Safety

 - `pool` must be a valid pointer to an FFIAddressPool that was allocated by this library
 - The pointer must not be used after calling this function
 - This function must only be called once per allocation
 */
 void address_pool_free(FFIAddressPool *pool) ;

/*
 Get address pool information for an account

 # Safety

 - `managed_wallet` must be a valid pointer to an FFIManagedWalletInfo
 - `info_out` must be a valid pointer to store the pool info
 - `error` must be a valid pointer to an FFIError or null
 */

bool managed_wallet_get_address_pool_info(const FFIManagedWalletInfo *managed_wallet,
                                          FFIAccountType account_type,
                                          unsigned int account_index,
                                          FFIAddressPoolType pool_type,
                                          FFIAddressPoolInfo *info_out,
                                          FFIError *error)
;

/*
 Set the gap limit for an address pool

 The gap limit determines how many unused addresses to maintain at the end
 of the pool. This is important for wallet recovery and address discovery.

 # Safety

 - `managed_wallet` must be a valid pointer to an FFIManagedWalletInfo
 - `error` must be a valid pointer to an FFIError or null
 */

bool managed_wallet_set_gap_limit(FFIManagedWalletInfo *managed_wallet,
                                  FFIAccountType account_type,
                                  unsigned int account_index,
                                  FFIAddressPoolType pool_type,
                                  unsigned int gap_limit,
                                  FFIError *error)
;

/*
 Generate addresses up to a specific index in a pool

 This ensures that addresses up to and including the specified index exist
 in the pool. This is useful for wallet recovery or when specific indices
 are needed.

 # Safety

 - `managed_wallet` must be a valid pointer to an FFIManagedWalletInfo
 - `wallet` must be a valid pointer to an FFIWallet (for key derivation)
 - `error` must be a valid pointer to an FFIError or null
 */

bool managed_wallet_generate_addresses_to_index(FFIManagedWalletInfo *managed_wallet,
                                                const FFIWallet *wallet,
                                                FFIAccountType account_type,
                                                unsigned int account_index,
                                                FFIAddressPoolType pool_type,
                                                unsigned int target_index,
                                                FFIError *error)
;

/*
 Mark an address as used in the pool

 This updates the pool's tracking of which addresses have been used,
 which is important for gap limit management and wallet recovery.

 # Safety

 - `managed_wallet` must be a valid pointer to an FFIManagedWalletInfo
 - `address` must be a valid C string
 - `error` must be a valid pointer to an FFIError or null
 */

bool managed_wallet_mark_address_used(FFIManagedWalletInfo *managed_wallet,
                                      const char *address,
                                      FFIError *error)
;

/*
 Get a single address info at a specific index from the pool

 Returns detailed information about the address at the given index, or NULL
 if the index is out of bounds or not generated yet.

 # Safety

 - `pool` must be a valid pointer to an FFIAddressPool
 - `error` must be a valid pointer to an FFIError or null
 - The returned FFIAddressInfo must be freed using `address_info_free`
 */

FFIAddressInfo *address_pool_get_address_at_index(const FFIAddressPool *pool,
                                                  uint32_t index,
                                                  FFIError *error)
;

/*
 Get a range of addresses from the pool

 Returns an array of FFIAddressInfo structures for addresses in the range [start_index, end_index).
 The count_out parameter will be set to the actual number of addresses returned.

 Note: This function only reads existing addresses from the pool. It does not generate new addresses.
 Use managed_wallet_generate_addresses_to_index if you need to generate addresses first.

 # Safety

 - `pool` must be a valid pointer to an FFIAddressPool
 - `count_out` must be a valid pointer to store the count
 - `error` must be a valid pointer to an FFIError or null
 - The returned array must be freed using `address_info_array_free`
 */

FFIAddressInfo **address_pool_get_addresses_in_range(const FFIAddressPool *pool,
                                                     uint32_t start_index,
                                                     uint32_t end_index,
                                                     size_t *count_out,
                                                     FFIError *error)
;

/*
 Free a single FFIAddressInfo structure

 # Safety

 - `info` must be a valid pointer to an FFIAddressInfo allocated by this library or null
 - The pointer must not be used after calling this function
 */
 void address_info_free(FFIAddressInfo *info) ;

/*
 Free an array of FFIAddressInfo structures

 # Safety

 - `infos` must be a valid pointer to an array of FFIAddressInfo pointers allocated by this library or null
 - `count` must be the exact number of elements in the array
 - The pointers must not be used after calling this function
 */

void address_info_array_free(FFIAddressInfo **infos,
                             size_t count)
;

/*
 Create a new master extended private key from seed

 # Safety

 - `seed` must be a valid pointer to a byte array of `seed_len` length
 - `error` must be a valid pointer to an FFIError structure or null
 - The caller must ensure the seed pointer remains valid for the duration of this call
 */

FFIExtendedPrivKey *derivation_new_master_key(const uint8_t *seed,
                                              size_t seed_len,
                                              FFINetwork network,
                                              FFIError *error)
;

/*
 Derive a BIP44 account path (m/44'/5'/account')
 */

bool derivation_bip44_account_path(FFINetwork network,
                                   unsigned int account_index,
                                   char *path_out,
                                   size_t path_max_len,
                                   FFIError *error)
;

/*
 Derive a BIP44 payment path (m/44'/5'/account'/change/index)
 */

bool derivation_bip44_payment_path(FFINetwork network,
                                   unsigned int account_index,
                                   bool is_change,
                                   unsigned int address_index,
                                   char *path_out,
                                   size_t path_max_len,
                                   FFIError *error)
;

/*
 Derive CoinJoin path (m/9'/5'/4'/account')
 */

bool derivation_coinjoin_path(FFINetwork network,
                              unsigned int account_index,
                              char *path_out,
                              size_t path_max_len,
                              FFIError *error)
;

/*
 Derive identity registration path (m/9'/5'/5'/1'/index')
 */

bool derivation_identity_registration_path(FFINetwork network,
                                           unsigned int identity_index,
                                           char *path_out,
                                           size_t path_max_len,
                                           FFIError *error)
;

/*
 Derive identity top-up path (m/9'/5'/5'/2'/identity_index'/top_up_index')
 */

bool derivation_identity_topup_path(FFINetwork network,
                                    unsigned int identity_index,
                                    unsigned int topup_index,
                                    char *path_out,
                                    size_t path_max_len,
                                    FFIError *error)
;

/*
 Derive identity authentication path (m/9'/5'/5'/0'/identity_index'/key_index')
 */

bool derivation_identity_authentication_path(FFINetwork network,
                                             unsigned int identity_index,
                                             unsigned int key_index,
                                             char *path_out,
                                             size_t path_max_len,
                                             FFIError *error)
;

/*
 Derive private key for a specific path from seed

 # Safety

 - `seed` must be a valid pointer to a byte array of `seed_len` length
 - `path` must be a valid pointer to a null-terminated C string
 - `error` must be a valid pointer to an FFIError structure or null
 - The caller must ensure all pointers remain valid for the duration of this call
 */

FFIExtendedPrivKey *derivation_derive_private_key_from_seed(const uint8_t *seed,
                                                            size_t seed_len,
                                                            const char *path,
                                                            FFINetwork network,
                                                            FFIError *error)
;

/*
 Derive public key from extended private key

 # Safety

 - `xpriv` must be a valid pointer to an FFIExtendedPrivKey
 - `error` must be a valid pointer to an FFIError
 - The returned pointer must be freed with `extended_public_key_free`
 */
 FFIExtendedPubKey *derivation_xpriv_to_xpub(const FFIExtendedPrivKey *xpriv, FFIError *error) ;

/*
 Get extended private key as string

 # Safety

 - `xpriv` must be a valid pointer to an FFIExtendedPrivKey
 - `error` must be a valid pointer to an FFIError
 - The returned string must be freed with `string_free`
 */
 char *derivation_xpriv_to_string(const FFIExtendedPrivKey *xpriv, FFIError *error) ;

/*
 Get extended public key as string

 # Safety

 - `xpub` must be a valid pointer to an FFIExtendedPubKey
 - `error` must be a valid pointer to an FFIError
 - The returned string must be freed with `string_free`
 */
 char *derivation_xpub_to_string(const FFIExtendedPubKey *xpub, FFIError *error) ;

/*
 Get fingerprint from extended public key (4 bytes)

 # Safety

 - `xpub` must be a valid pointer to an FFIExtendedPubKey
 - `fingerprint_out` must be a valid pointer to a buffer of at least 4 bytes
 - `error` must be a valid pointer to an FFIError
 */

bool derivation_xpub_fingerprint(const FFIExtendedPubKey *xpub,
                                 uint8_t *fingerprint_out,
                                 FFIError *error)
;

/*
 Free extended private key

 # Safety

 - `xpriv` must be a valid pointer to an FFIExtendedPrivKey that was allocated by this library
 - The pointer must not be used after calling this function
 - This function must only be called once per allocation
 */
 void derivation_xpriv_free(FFIExtendedPrivKey *xpriv) ;

/*
 Free extended public key

 # Safety

 - `xpub` must be a valid pointer to an FFIExtendedPubKey that was allocated by this library
 - The pointer must not be used after calling this function
 - This function must only be called once per allocation
 */
 void derivation_xpub_free(FFIExtendedPubKey *xpub) ;

/*
 Free derivation path string

 # Safety

 - `s` must be a valid pointer to a C string that was allocated by this library
 - The pointer must not be used after calling this function
 - This function must only be called once per allocation
 */
 void derivation_string_free(char *s) ;

/*
 Derive an address from a private key

 # Safety
 - `private_key` must be a valid pointer to 32 bytes
 - `network` is the network for the address

 # Returns
 - Pointer to C string with address (caller must free)
 - NULL on error
 */
 char *key_wallet_derive_address_from_key(const uint8_t *private_key, FFINetwork network) ;

/*
 Derive an address from a seed at a specific derivation path

 # Safety
 - `seed` must be a valid pointer to 64 bytes
 - `network` is the network for the address
 - `path` must be a valid null-terminated C string (e.g., "m/44'/5'/0'/0/0")

 # Returns
 - Pointer to C string with address (caller must free)
 - NULL on error
 */

char *key_wallet_derive_address_from_seed(const uint8_t *seed,
                                          FFINetwork network,
                                          const char *path)
;

/*
 Derive a private key from a seed at a specific derivation path

 # Safety
 - `seed` must be a valid pointer to 64 bytes
 - `path` must be a valid null-terminated C string (e.g., "m/44'/5'/0'/0/0")
 - `key_out` must be a valid pointer to a buffer of at least 32 bytes

 # Returns
 - 0 on success
 - -1 on error
 */

int32_t key_wallet_derive_private_key_from_seed(const uint8_t *seed,
                                                const char *path,
                                                uint8_t *key_out)
;

/*
 Free an error message

 # Safety

 - `message` must be a valid pointer to a C string that was allocated by this library
 - The pointer must not be used after calling this function
 - This function must only be called once per allocation
 */
 void error_message_free(char *message) ;

/*
 Get extended private key for account

 # Safety

 - `wallet` must be a valid pointer to an FFIWallet
 - `error` must be a valid pointer to an FFIError
 - The returned string must be freed with `string_free`
 */

char *wallet_get_account_xpriv(const FFIWallet *wallet,
                               unsigned int account_index,
                               FFIError *error)
;

/*
 Get extended public key for account

 # Safety

 - `wallet` must be a valid pointer to an FFIWallet
 - `error` must be a valid pointer to an FFIError
 - The returned string must be freed with `string_free`
 */

char *wallet_get_account_xpub(const FFIWallet *wallet,
                              unsigned int account_index,
                              FFIError *error)
;

/*
 Derive private key at a specific path
 Returns an opaque FFIPrivateKey pointer that must be freed with private_key_free

 # Safety

 - `wallet` must be a valid pointer to an FFIWallet
 - `derivation_path` must be a valid null-terminated C string
 - `error` must be a valid pointer to an FFIError
 - The returned pointer must be freed with `private_key_free`
 */

FFIPrivateKey *wallet_derive_private_key(const FFIWallet *wallet,
                                         const char *derivation_path,
                                         FFIError *error)
;

/*
 Derive extended private key at a specific path
 Returns an opaque FFIExtendedPrivateKey pointer that must be freed with extended_private_key_free

 # Safety

 - `wallet` must be a valid pointer to an FFIWallet
 - `derivation_path` must be a valid null-terminated C string
 - `error` must be a valid pointer to an FFIError
 - The returned pointer must be freed with `extended_private_key_free`
 */

FFIExtendedPrivateKey *wallet_derive_extended_private_key(const FFIWallet *wallet,
                                                          const char *derivation_path,
                                                          FFIError *error)
;

/*
 Derive private key at a specific path and return as WIF string

 # Safety

 - `wallet` must be a valid pointer to an FFIWallet
 - `derivation_path` must be a valid null-terminated C string
 - `error` must be a valid pointer to an FFIError
 - The returned string must be freed with `string_free`
 */

char *wallet_derive_private_key_as_wif(const FFIWallet *wallet,
                                       const char *derivation_path,
                                       FFIError *error)
;

/*
 Free a private key

 # Safety

 - `key` must be a valid pointer created by private key functions or null
 - After calling this function, the pointer becomes invalid
 */
 void private_key_free(FFIPrivateKey *key) ;

/*
 Free an extended private key

 # Safety

 - `key` must be a valid pointer created by extended private key functions or null
 - After calling this function, the pointer becomes invalid
 */
 void extended_private_key_free(FFIExtendedPrivateKey *key) ;

/*
 Get extended private key as string (xprv format)

 Returns the extended private key in base58 format (xprv... for mainnet, tprv... for testnet)

 # Safety

 - `key` must be a valid pointer to an FFIExtendedPrivateKey
 - `network` is ignored; the network is encoded in the extended key
 - `error` must be a valid pointer to an FFIError
 - The returned string must be freed with `string_free`
 */

char *extended_private_key_to_string(const FFIExtendedPrivateKey *key,
                                     FFINetwork network,
                                     FFIError *error)
;

/*
 Get the private key from an extended private key

 Extracts the non-extended private key from an extended private key.

 # Safety

 - `extended_key` must be a valid pointer to an FFIExtendedPrivateKey
 - `error` must be a valid pointer to an FFIError
 - The returned FFIPrivateKey must be freed with `private_key_free`
 */

FFIPrivateKey *extended_private_key_get_private_key(const FFIExtendedPrivateKey *extended_key,
                                                    FFIError *error)
;

/*
 Get private key as WIF string from FFIPrivateKey

 # Safety

 - `key` must be a valid pointer to an FFIPrivateKey
 - `error` must be a valid pointer to an FFIError
 - The returned string must be freed with `string_free`
 */
 char *private_key_to_wif(const FFIPrivateKey *key, FFINetwork network, FFIError *error) ;

/*
 Derive public key at a specific path
 Returns an opaque FFIPublicKey pointer that must be freed with public_key_free

 # Safety

 - `wallet` must be a valid pointer to an FFIWallet
 - `derivation_path` must be a valid null-terminated C string
 - `error` must be a valid pointer to an FFIError
 - The returned pointer must be freed with `public_key_free`
 */

FFIPublicKey *wallet_derive_public_key(const FFIWallet *wallet,
                                       const char *derivation_path,
                                       FFIError *error)
;

/*
 Derive extended public key at a specific path
 Returns an opaque FFIExtendedPublicKey pointer that must be freed with extended_public_key_free

 # Safety

 - `wallet` must be a valid pointer to an FFIWallet
 - `derivation_path` must be a valid null-terminated C string
 - `error` must be a valid pointer to an FFIError
 - The returned pointer must be freed with `extended_public_key_free`
 */

FFIExtendedPublicKey *wallet_derive_extended_public_key(const FFIWallet *wallet,
                                                        const char *derivation_path,
                                                        FFIError *error)
;

/*
 Derive public key at a specific path and return as hex string

 # Safety

 - `wallet` must be a valid pointer to an FFIWallet
 - `derivation_path` must be a valid null-terminated C string
 - `error` must be a valid pointer to an FFIError
 - The returned string must be freed with `string_free`
 */

char *wallet_derive_public_key_as_hex(const FFIWallet *wallet,
                                      const char *derivation_path,
                                      FFIError *error)
;

/*
 Free a public key

 # Safety

 - `key` must be a valid pointer created by public key functions or null
 - After calling this function, the pointer becomes invalid
 */
 void public_key_free(FFIPublicKey *key) ;

/*
 Free an extended public key

 # Safety

 - `key` must be a valid pointer created by extended public key functions or null
 - After calling this function, the pointer becomes invalid
 */
 void extended_public_key_free(FFIExtendedPublicKey *key) ;

/*
 Get extended public key as string (xpub format)

 Returns the extended public key in base58 format (xpub... for mainnet, tpub... for testnet)

 # Safety

 - `key` must be a valid pointer to an FFIExtendedPublicKey
 - `network` is ignored; the network is encoded in the extended key
 - `error` must be a valid pointer to an FFIError
 - The returned string must be freed with `string_free`
 */

char *extended_public_key_to_string(const FFIExtendedPublicKey *key,
                                    FFINetwork network,
                                    FFIError *error)
;

/*
 Get the public key from an extended public key

 Extracts the non-extended public key from an extended public key.

 # Safety

 - `extended_key` must be a valid pointer to an FFIExtendedPublicKey
 - `error` must be a valid pointer to an FFIError
 - The returned FFIPublicKey must be freed with `public_key_free`
 */

FFIPublicKey *extended_public_key_get_public_key(const FFIExtendedPublicKey *extended_key,
                                                 FFIError *error)
;

/*
 Get public key as hex string from FFIPublicKey

 # Safety

 - `key` must be a valid pointer to an FFIPublicKey
 - `error` must be a valid pointer to an FFIError
 - The returned string must be freed with `string_free`
 */
 char *public_key_to_hex(const FFIPublicKey *key, FFIError *error) ;

/*
 Convert derivation path string to indices

 # Safety

 - `path` must be a valid null-terminated C string or null
 - `indices_out` must be a valid pointer to store the indices array pointer
 - `hardened_out` must be a valid pointer to store the hardened flags array pointer
 - `count_out` must be a valid pointer to store the count
 - `error` must be a valid pointer to an FFIError
 - The returned arrays must be freed with `derivation_path_free`
 */

bool derivation_path_parse(const char *path,
                           uint32_t **indices_out,
                           bool **hardened_out,
                           size_t *count_out,
                           FFIError *error)
;

/*
 Free derivation path arrays
 Note: This function expects the count to properly free the slices

 # Safety

 - `indices` must be a valid pointer created by `derivation_path_parse` or null
 - `hardened` must be a valid pointer created by `derivation_path_parse` or null
 - `count` must match the count from `derivation_path_parse`
 - After calling this function, the pointers become invalid
 */
 void derivation_path_free(uint32_t *indices, bool *hardened, size_t count) ;

/*
 Get a managed account from a managed wallet

 This function gets a ManagedAccount from the wallet manager's managed wallet info,
 returning a managed account handle that wraps the ManagedAccount.

 # Safety

 - `manager` must be a valid pointer to an FFIWalletManager instance
 - `wallet_id` must be a valid pointer to a 32-byte wallet ID
 - The caller must ensure all pointers remain valid for the duration of this call
 - The returned account must be freed with `managed_account_free` when no longer needed
 */

FFIManagedAccountResult managed_wallet_get_account(const FFIWalletManager *manager,
                                                   const uint8_t *wallet_id,
                                                   unsigned int account_index,
                                                   FFIAccountType account_type)
;

/*
 Get a managed IdentityTopUp account with a specific registration index

 This is used for top-up accounts that are bound to a specific identity.
 Returns a managed account handle that wraps the ManagedAccount.

 # Safety

 - `manager` must be a valid pointer to an FFIWalletManager instance
 - `wallet_id` must be a valid pointer to a 32-byte wallet ID
 - The caller must ensure all pointers remain valid for the duration of this call
 - The returned account must be freed with `managed_account_free` when no longer needed
 */

FFIManagedAccountResult managed_wallet_get_top_up_account_with_registration_index(const FFIWalletManager *manager,
                                                                                  const uint8_t *wallet_id,
                                                                                  unsigned int registration_index)
;

/*
 Get a managed DashPay receiving funds account by composite key

 # Safety
 - `manager`, `wallet_id` must be valid
 - `user_identity_id` and `friend_identity_id` must each point to 32 bytes
 */

FFIManagedAccountResult managed_wallet_get_dashpay_receiving_account(const FFIWalletManager *manager,
                                                                     const uint8_t *wallet_id,
                                                                     unsigned int account_index,
                                                                     const uint8_t *user_identity_id,
                                                                     const uint8_t *friend_identity_id)
;

/*
 Get a managed DashPay external account by composite key

 # Safety
 - Pointers must be valid
 */

FFIManagedAccountResult managed_wallet_get_dashpay_external_account(const FFIWalletManager *manager,
                                                                    const uint8_t *wallet_id,
                                                                    unsigned int account_index,
                                                                    const uint8_t *user_identity_id,
                                                                    const uint8_t *friend_identity_id)
;

/*
 Get the network of a managed account

 # Safety

 - `account` must be a valid pointer to an FFIManagedAccount instance
 - Returns `FFINetwork::Dash` if the account is null
 */
 FFINetwork managed_account_get_network(const FFIManagedAccount *account) ;

/*
 Get the parent wallet ID of a managed account

 Note: ManagedAccount doesn't store the parent wallet ID directly.
 The wallet ID is typically known from the context (e.g., when getting the account from a managed wallet).

 # Safety

 - `wallet_id` must be a valid pointer to a 32-byte wallet ID buffer that was provided by the caller
 - The returned pointer is the same as the input pointer for convenience
 - The caller must not free the returned pointer as it's the same as the input
 */

const uint8_t *managed_account_get_parent_wallet_id(const uint8_t *wallet_id)
;

/*
 Get the account type of a managed account

 # Safety

 - `account` must be a valid pointer to an FFIManagedAccount instance
 - `index_out` must be a valid pointer to receive the account index (or null)
 */

FFIAccountType managed_account_get_account_type(const FFIManagedAccount *account,
                                                unsigned int *index_out)
;

/*
 Check if a managed account is watch-only

 # Safety

 - `account` must be a valid pointer to an FFIManagedAccount instance
 */
 bool managed_account_get_is_watch_only(const FFIManagedAccount *account) ;

/*
 Get the balance of a managed account

 # Safety

 - `account` must be a valid pointer to an FFIManagedAccount instance
 - `balance_out` must be a valid pointer to an FFIBalance structure
 */
 bool managed_account_get_balance(const FFIManagedAccount *account, FFIBalance *balance_out) ;

/*
 Get the number of transactions in a managed account

 # Safety

 - `account` must be a valid pointer to an FFIManagedAccount instance
 */
 unsigned int managed_account_get_transaction_count(const FFIManagedAccount *account) ;

/*
 Get the number of UTXOs in a managed account

 # Safety

 - `account` must be a valid pointer to an FFIManagedAccount instance
 */
 unsigned int managed_account_get_utxo_count(const FFIManagedAccount *account) ;

/*
 Get all transactions from a managed account

 Returns an array of FFITransactionRecord structures.

 # Safety

 - `account` must be a valid pointer to an FFIManagedAccount instance
 - `transactions_out` must be a valid pointer to receive the transactions array pointer
 - `count_out` must be a valid pointer to receive the count
 - The caller must free the returned array using `managed_account_free_transactions`
 */

bool managed_account_get_transactions(const FFIManagedAccount *account,
                                      FFITransactionRecord **transactions_out,
                                      size_t *count_out)
;

/*
 Free transactions array returned by managed_account_get_transactions

 # Safety

 - `transactions` must be a pointer returned by `managed_account_get_transactions`
 - `count` must be the count returned by `managed_account_get_transactions`
 - This function must only be called once per allocation
 */
 void managed_account_free_transactions(FFITransactionRecord *transactions, size_t count) ;

/*
 Free a managed account handle

 # Safety

 - `account` must be a valid pointer to an FFIManagedAccount that was allocated by this library
 - The pointer must not be used after calling this function
 - This function must only be called once per allocation
 */
 void managed_account_free(FFIManagedAccount *account) ;

/*
 Free a managed account result's error message (if any)
 Note: This does NOT free the account handle itself - use managed_account_free for that

 # Safety

 - `result` must be a valid pointer to an FFIManagedAccountResult
 - The error_message field must be either null or a valid CString allocated by this library
 - The caller must ensure the result pointer remains valid for the duration of this call
 */
 void managed_account_result_free_error(FFIManagedAccountResult *result) ;

/*
 Get number of accounts in a managed wallet

 # Safety

 - `manager` must be a valid pointer to an FFIWalletManager instance
 - `wallet_id` must be a valid pointer to a 32-byte wallet ID
 - `error` must be a valid pointer to an FFIError structure or null
 - The caller must ensure all pointers remain valid for the duration of this call
 */

unsigned int managed_wallet_get_account_count(const FFIWalletManager *manager,
                                              const uint8_t *wallet_id,
                                              FFIError *error)
;

/*
 Get the account index from a managed account

 Returns the primary account index for Standard and CoinJoin accounts.
 Returns 0 for account types that don't have an index (like Identity or Provider accounts).

 # Safety

 - `account` must be a valid pointer to an FFIManagedAccount instance
 */
 unsigned int managed_account_get_index(const FFIManagedAccount *account) ;

/*
 Get the external address pool from a managed account

 This function returns the external (receive) address pool for Standard accounts.
 Returns NULL for account types that don't have separate external/internal pools.

 # Safety

 - `account` must be a valid pointer to an FFIManagedAccount instance
 - The returned pool must be freed with `address_pool_free` when no longer needed
 */
 FFIAddressPool *managed_account_get_external_address_pool(const FFIManagedAccount *account) ;

/*
 Get the internal address pool from a managed account

 This function returns the internal (change) address pool for Standard accounts.
 Returns NULL for account types that don't have separate external/internal pools.

 # Safety

 - `account` must be a valid pointer to an FFIManagedAccount instance
 - The returned pool must be freed with `address_pool_free` when no longer needed
 */
 FFIAddressPool *managed_account_get_internal_address_pool(const FFIManagedAccount *account) ;

/*
 Get an address pool from a managed account by type

 This function returns the appropriate address pool based on the pool type parameter.
 For Standard accounts with External/Internal pool types, returns the corresponding pool.
 For non-standard accounts with Single pool type, returns their single address pool.

 # Safety

 - `manager` must be a valid pointer to an FFIWalletManager instance
 - `account` must be a valid pointer to an FFIManagedAccount instance
 - `wallet_id` must be a valid pointer to a 32-byte wallet ID
 - The returned pool must be freed with `address_pool_free` when no longer needed
 */

FFIAddressPool *managed_account_get_address_pool(const FFIManagedAccount *account,
                                                 FFIAddressPoolType pool_type)
;

/*
 Get a managed platform payment account from a managed wallet

 Platform Payment accounts (DIP-17) are identified by account index and key_class.
 Returns a platform account handle that wraps the ManagedPlatformAccount.

 # Safety

 - `manager` must be a valid pointer to an FFIWalletManager instance
 - `wallet_id` must be a valid pointer to a 32-byte wallet ID
 - The caller must ensure all pointers remain valid for the duration of this call
 - The returned account must be freed with `managed_platform_account_free` when no longer needed
 */

FFIManagedPlatformAccountResult managed_wallet_get_platform_payment_account(const FFIWalletManager *manager,
                                                                            const uint8_t *wallet_id,
                                                                            unsigned int account_index,
                                                                            unsigned int key_class)
;

/*
 Get the network of a managed platform account

 # Safety

 - `account` must be a valid pointer to an FFIManagedPlatformAccount instance
 - Returns `FFINetwork::Dash` if the account is null
 */
 FFINetwork managed_platform_account_get_network(const FFIManagedPlatformAccount *account) ;

/*
 Get the account index of a managed platform account

 # Safety

 - `account` must be a valid pointer to an FFIManagedPlatformAccount instance
 */
 unsigned int managed_platform_account_get_account_index(const FFIManagedPlatformAccount *account) ;

/*
 Get the key class of a managed platform account

 # Safety

 - `account` must be a valid pointer to an FFIManagedPlatformAccount instance
 */
 unsigned int managed_platform_account_get_key_class(const FFIManagedPlatformAccount *account) ;

/*
 Get the total credit balance of a managed platform account

 Returns the balance in credits (1000 credits = 1 duff)

 # Safety

 - `account` must be a valid pointer to an FFIManagedPlatformAccount instance
 */
 uint64_t managed_platform_account_get_credit_balance(const FFIManagedPlatformAccount *account) ;

/*
 Get the total balance in duffs of a managed platform account

 Returns the balance in duffs (credit_balance / 1000)

 # Safety

 - `account` must be a valid pointer to an FFIManagedPlatformAccount instance
 */
 uint64_t managed_platform_account_get_duff_balance(const FFIManagedPlatformAccount *account) ;

/*
 Get the number of funded addresses in a managed platform account

 # Safety

 - `account` must be a valid pointer to an FFIManagedPlatformAccount instance
 */

unsigned int managed_platform_account_get_funded_address_count(const FFIManagedPlatformAccount *account)
;

/*
 Get the total number of addresses in a managed platform account

 # Safety

 - `account` must be a valid pointer to an FFIManagedPlatformAccount instance
 */

unsigned int managed_platform_account_get_total_address_count(const FFIManagedPlatformAccount *account)
;

/*
 Check if a managed platform account is watch-only

 # Safety

 - `account` must be a valid pointer to an FFIManagedPlatformAccount instance
 */
 bool managed_platform_account_get_is_watch_only(const FFIManagedPlatformAccount *account) ;

/*
 Get the address pool from a managed platform account

 Platform accounts only have a single address pool.

 # Safety

 - `account` must be a valid pointer to an FFIManagedPlatformAccount instance
 - The returned pool must be freed with `address_pool_free` when no longer needed
 */

FFIAddressPool *managed_platform_account_get_address_pool(const FFIManagedPlatformAccount *account)
;

/*
 Free a managed platform account handle

 # Safety

 - `account` must be a valid pointer to an FFIManagedPlatformAccount that was allocated by this library
 - The pointer must not be used after calling this function
 - This function must only be called once per allocation
 */

void managed_platform_account_free(FFIManagedPlatformAccount *account)
;

/*
 Free a managed platform account result's error message (if any)
 Note: This does NOT free the account handle itself - use managed_platform_account_free for that

 # Safety

 - `result` must be a valid pointer to an FFIManagedPlatformAccountResult
 - The error_message field must be either null or a valid CString allocated by this library
 - The caller must ensure the result pointer remains valid for the duration of this call
 */
 void managed_platform_account_result_free_error(FFIManagedPlatformAccountResult *result) ;

/*
 Get managed account collection for a specific network from wallet manager

 # Safety

 - `manager` must be a valid pointer to an FFIWalletManager instance
 - `wallet_id` must be a valid pointer to a 32-byte wallet ID
 - `error` must be a valid pointer to an FFIError structure or null
 - The returned pointer must be freed with `managed_account_collection_free` when no longer needed
 */

FFIManagedAccountCollection *managed_wallet_get_account_collection(const FFIWalletManager *manager,
                                                                   const uint8_t *wallet_id,
                                                                   FFIError *error)
;

/*
 Free a managed account collection handle

 # Safety

 - `collection` must be a valid pointer to an FFIManagedAccountCollection created by this library
 - `collection` must not be used after calling this function
 */
 void managed_account_collection_free(FFIManagedAccountCollection *collection) ;

/*
 Get a BIP44 account by index from the managed collection

 # Safety

 - `collection` must be a valid pointer to an FFIManagedAccountCollection
 - The returned pointer must be freed with `managed_account_free` when no longer needed
 */

FFIManagedAccount *managed_account_collection_get_bip44_account(const FFIManagedAccountCollection *collection,
                                                                unsigned int index)
;

/*
 Get all BIP44 account indices from managed collection

 # Safety

 - `collection` must be a valid pointer to an FFIManagedAccountCollection
 - `out_indices` must be a valid pointer to store the indices array
 - `out_count` must be a valid pointer to store the count
 - The returned array must be freed with `free_u32_array` when no longer needed
 */

bool managed_account_collection_get_bip44_indices(const FFIManagedAccountCollection *collection,
                                                  unsigned int **out_indices,
                                                  size_t *out_count)
;

/*
 Get a BIP32 account by index from the managed collection

 # Safety

 - `collection` must be a valid pointer to an FFIManagedAccountCollection
 - The returned pointer must be freed with `managed_account_free` when no longer needed
 */

FFIManagedAccount *managed_account_collection_get_bip32_account(const FFIManagedAccountCollection *collection,
                                                                unsigned int index)
;

/*
 Get all BIP32 account indices from managed collection

 # Safety

 - `collection` must be a valid pointer to an FFIManagedAccountCollection
 - `out_indices` must be a valid pointer to store the indices array
 - `out_count` must be a valid pointer to store the count
 - The returned array must be freed with `free_u32_array` when no longer needed
 */

bool managed_account_collection_get_bip32_indices(const FFIManagedAccountCollection *collection,
                                                  unsigned int **out_indices,
                                                  size_t *out_count)
;

/*
 Get a CoinJoin account by index from the managed collection

 # Safety

 - `collection` must be a valid pointer to an FFIManagedAccountCollection
 - The returned pointer must be freed with `managed_account_free` when no longer needed
 */

FFIManagedAccount *managed_account_collection_get_coinjoin_account(const FFIManagedAccountCollection *collection,
                                                                   unsigned int index)
;

/*
 Get all CoinJoin account indices from managed collection

 # Safety

 - `collection` must be a valid pointer to an FFIManagedAccountCollection
 - `out_indices` must be a valid pointer to store the indices array
 - `out_count` must be a valid pointer to store the count
 - The returned array must be freed with `free_u32_array` when no longer needed
 */

bool managed_account_collection_get_coinjoin_indices(const FFIManagedAccountCollection *collection,
                                                     unsigned int **out_indices,
                                                     size_t *out_count)
;

/*
 Get the identity registration account if it exists in managed collection

 # Safety

 - `collection` must be a valid pointer to an FFIManagedAccountCollection
 - The returned pointer must be freed with `managed_account_free` when no longer needed
 */

FFIManagedAccount *managed_account_collection_get_identity_registration(const FFIManagedAccountCollection *collection)
;

/*
 Check if identity registration account exists in managed collection

 # Safety

 - `collection` must be a valid pointer to an FFIManagedAccountCollection
 */

bool managed_account_collection_has_identity_registration(const FFIManagedAccountCollection *collection)
;

/*
 Get an identity topup account by registration index from managed collection

 # Safety

 - `collection` must be a valid pointer to an FFIManagedAccountCollection
 - The returned pointer must be freed with `managed_account_free` when no longer needed
 */

FFIManagedAccount *managed_account_collection_get_identity_topup(const FFIManagedAccountCollection *collection,
                                                                 unsigned int registration_index)
;

/*
 Get all identity topup registration indices from managed collection

 # Safety

 - `collection` must be a valid pointer to an FFIManagedAccountCollection
 - `out_indices` must be a valid pointer to store the indices array
 - `out_count` must be a valid pointer to store the count
 - The returned array must be freed with `free_u32_array` when no longer needed
 */

bool managed_account_collection_get_identity_topup_indices(const FFIManagedAccountCollection *collection,
                                                           unsigned int **out_indices,
                                                           size_t *out_count)
;

/*
 Get the identity topup not bound account if it exists in managed collection

 # Safety

 - `collection` must be a valid pointer to an FFIManagedAccountCollection
 - `manager` must be a valid pointer to an FFIWalletManager
 - The returned pointer must be freed with `managed_account_free` when no longer needed
 */

FFIManagedAccount *managed_account_collection_get_identity_topup_not_bound(const FFIManagedAccountCollection *collection)
;

/*
 Check if identity topup not bound account exists in managed collection

 # Safety

 - `collection` must be a valid pointer to an FFIManagedAccountCollection
 */

bool managed_account_collection_has_identity_topup_not_bound(const FFIManagedAccountCollection *collection)
;

/*
 Get the identity invitation account if it exists in managed collection

 # Safety

 - `collection` must be a valid pointer to an FFIManagedAccountCollection
 - The returned pointer must be freed with `managed_account_free` when no longer needed
 */

FFIManagedAccount *managed_account_collection_get_identity_invitation(const FFIManagedAccountCollection *collection)
;

/*
 Check if identity invitation account exists in managed collection

 # Safety

 - `collection` must be a valid pointer to an FFIManagedAccountCollection
 */

bool managed_account_collection_has_identity_invitation(const FFIManagedAccountCollection *collection)
;

/*
 Get the provider voting keys account if it exists in managed collection

 # Safety

 - `collection` must be a valid pointer to an FFIManagedAccountCollection
 - The returned pointer must be freed with `managed_account_free` when no longer needed
 */

FFIManagedAccount *managed_account_collection_get_provider_voting_keys(const FFIManagedAccountCollection *collection)
;

/*
 Check if provider voting keys account exists in managed collection

 # Safety

 - `collection` must be a valid pointer to an FFIManagedAccountCollection
 */

bool managed_account_collection_has_provider_voting_keys(const FFIManagedAccountCollection *collection)
;

/*
 Get the provider owner keys account if it exists in managed collection

 # Safety

 - `collection` must be a valid pointer to an FFIManagedAccountCollection
 - The returned pointer must be freed with `managed_account_free` when no longer needed
 */

FFIManagedAccount *managed_account_collection_get_provider_owner_keys(const FFIManagedAccountCollection *collection)
;

/*
 Check if provider owner keys account exists in managed collection

 # Safety

 - `collection` must be a valid pointer to an FFIManagedAccountCollection
 */

bool managed_account_collection_has_provider_owner_keys(const FFIManagedAccountCollection *collection)
;

/*
 Get the provider operator keys account if it exists in managed collection
 Note: Returns null if the `bls` feature is not enabled

 # Safety

 - `collection` must be a valid pointer to an FFIManagedAccountCollection
 - The returned pointer must be freed with `managed_account_free` when no longer needed (when BLS is enabled)
 */

void *managed_account_collection_get_provider_operator_keys(const FFIManagedAccountCollection *collection)
;

/*
 Check if provider operator keys account exists in managed collection

 # Safety

 - `collection` must be a valid pointer to an FFIManagedAccountCollection
 */

bool managed_account_collection_has_provider_operator_keys(const FFIManagedAccountCollection *collection)
;

/*
 Get the provider platform keys account if it exists in managed collection
 Note: Returns null if the `eddsa` feature is not enabled

 # Safety

 - `collection` must be a valid pointer to an FFIManagedAccountCollection
 - The returned pointer must be freed with `managed_account_free` when no longer needed (when EdDSA is enabled)
 */

void *managed_account_collection_get_provider_platform_keys(const FFIManagedAccountCollection *collection)
;

/*
 Check if provider platform keys account exists in managed collection

 # Safety

 - `collection` must be a valid pointer to an FFIManagedAccountCollection
 */

bool managed_account_collection_has_provider_platform_keys(const FFIManagedAccountCollection *collection)
;

/*
 Get a Platform Payment account by account index and key class from the managed collection

 Platform Payment accounts (DIP-17) are identified by two indices:
 - account_index: The account' level in the derivation path
 - key_class: The key_class' level in the derivation path (typically 0)

 # Safety

 - `collection` must be a valid pointer to an FFIManagedAccountCollection
 - The returned pointer must be freed with `managed_platform_account_free` when no longer needed
 */

FFIManagedPlatformAccount *managed_account_collection_get_platform_payment_account(const FFIManagedAccountCollection *collection,
                                                                                   unsigned int account_index,
                                                                                   unsigned int key_class)
;

/*
 Get all Platform Payment account keys from managed collection

 Returns an array of FFIPlatformPaymentAccountKey structures.

 # Safety

 - `collection` must be a valid pointer to an FFIManagedAccountCollection
 - `out_keys` must be a valid pointer to store the keys array
 - `out_count` must be a valid pointer to store the count
 - The returned array must be freed with `managed_account_collection_free_platform_payment_keys` when no longer needed
 */

bool managed_account_collection_get_platform_payment_keys(const FFIManagedAccountCollection *collection,
                                                          FFIPlatformPaymentAccountKey **out_keys,
                                                          size_t *out_count)
;

/*
 Free platform payment keys array returned by managed_account_collection_get_platform_payment_keys

 # Safety

 - `keys` must be a pointer returned by `managed_account_collection_get_platform_payment_keys`
 - `count` must be the count returned by `managed_account_collection_get_platform_payment_keys`
 - This function must only be called once per allocation
 */

void managed_account_collection_free_platform_payment_keys(FFIPlatformPaymentAccountKey *keys,
                                                           size_t count)
;

/*
 Check if there are any Platform Payment accounts in the managed collection

 # Safety

 - `collection` must be a valid pointer to an FFIManagedAccountCollection
 */

bool managed_account_collection_has_platform_payment_accounts(const FFIManagedAccountCollection *collection)
;

/*
 Get the number of Platform Payment accounts in the managed collection

 # Safety

 - `collection` must be a valid pointer to an FFIManagedAccountCollection
 */

unsigned int managed_account_collection_platform_payment_count(const FFIManagedAccountCollection *collection)
;

/*
 Get the total number of accounts in the managed collection

 # Safety

 - `collection` must be a valid pointer to an FFIManagedAccountCollection
 */
 unsigned int managed_account_collection_count(const FFIManagedAccountCollection *collection) ;

/*
 Get a human-readable summary of all accounts in the managed collection

 Returns a formatted string showing all account types and their indices.
 The format is designed to be clear and readable for end users.

 # Safety

 - `collection` must be a valid pointer to an FFIManagedAccountCollection
 - The returned string must be freed with `string_free` when no longer needed
 - Returns null if the collection pointer is null
 */
 char *managed_account_collection_summary(const FFIManagedAccountCollection *collection) ;

/*
 Get structured account collection summary data for managed collection

 Returns a struct containing arrays of indices for each account type and boolean
 flags for special accounts. This provides Swift with programmatic access to
 account information.

 # Safety

 - `collection` must be a valid pointer to an FFIManagedAccountCollection
 - The returned pointer must be freed with `managed_account_collection_summary_free` when no longer needed
 - Returns null if the collection pointer is null
 */

FFIManagedAccountCollectionSummary *managed_account_collection_summary_data(const FFIManagedAccountCollection *collection)
;

/*
 Free a managed account collection summary and all its allocated memory

 # Safety

 - `summary` must be a valid pointer to an FFIManagedAccountCollectionSummary created by `managed_account_collection_summary_data`
 - `summary` must not be used after calling this function
 */

void managed_account_collection_summary_free(FFIManagedAccountCollectionSummary *summary)
;

/*
 Get the next unused receive address

 Generates the next unused receive address for the specified account.
 This properly manages address gaps and updates the managed wallet state.

 # Safety

 - `managed_wallet` must be a valid pointer to an FFIManagedWalletInfo
 - `wallet` must be a valid pointer to an FFIWallet
 - `error` must be a valid pointer to an FFIError
 - The returned string must be freed by the caller
 */

char *managed_wallet_get_next_bip44_receive_address(FFIManagedWalletInfo *managed_wallet,
                                                    const FFIWallet *wallet,
                                                    unsigned int account_index,
                                                    FFIError *error)
;

/*
 Get the next unused change address

 Generates the next unused change address for the specified account.
 This properly manages address gaps and updates the managed wallet state.

 # Safety

 - `managed_wallet` must be a valid pointer to an FFIManagedWalletInfo
 - `wallet` must be a valid pointer to an FFIWallet
 - `error` must be a valid pointer to an FFIError
 - The returned string must be freed by the caller
 */

char *managed_wallet_get_next_bip44_change_address(FFIManagedWalletInfo *managed_wallet,
                                                   const FFIWallet *wallet,
                                                   unsigned int account_index,
                                                   FFIError *error)
;

/*
 Get BIP44 external (receive) addresses in the specified range

 Returns external addresses from start_index (inclusive) to end_index (exclusive).
 If addresses in the range haven't been generated yet, they will be generated.

 # Safety

 - `managed_wallet` must be a valid pointer to an FFIManagedWalletInfo
 - `wallet` must be a valid pointer to an FFIWallet
 - `addresses_out` must be a valid pointer to store the address array pointer
 - `count_out` must be a valid pointer to store the count
 - `error` must be a valid pointer to an FFIError
 - Free the result with address_array_free(addresses_out, count_out)
 */

bool managed_wallet_get_bip_44_external_address_range(FFIManagedWalletInfo *managed_wallet,
                                                      const FFIWallet *wallet,
                                                      unsigned int account_index,
                                                      unsigned int start_index,
                                                      unsigned int end_index,
                                                      char ***addresses_out,
                                                      size_t *count_out,
                                                      FFIError *error)
;

/*
 Get BIP44 internal (change) addresses in the specified range

 Returns internal addresses from start_index (inclusive) to end_index (exclusive).
 If addresses in the range haven't been generated yet, they will be generated.

 # Safety

 - `managed_wallet` must be a valid pointer to an FFIManagedWalletInfo
 - `wallet` must be a valid pointer to an FFIWallet
 - `addresses_out` must be a valid pointer to store the address array pointer
 - `count_out` must be a valid pointer to store the count
 - `error` must be a valid pointer to an FFIError
 - Free the result with address_array_free(addresses_out, count_out)
 */

bool managed_wallet_get_bip_44_internal_address_range(FFIManagedWalletInfo *managed_wallet,
                                                      const FFIWallet *wallet,
                                                      unsigned int account_index,
                                                      unsigned int start_index,
                                                      unsigned int end_index,
                                                      char ***addresses_out,
                                                      size_t *count_out,
                                                      FFIError *error)
;

/*
 Get wallet balance from managed wallet info

 Returns the balance breakdown including confirmed, unconfirmed, immature, locked, and total amounts.

 # Safety

 - `managed_wallet` must be a valid pointer to an FFIManagedWalletInfo
 - `confirmed_out` must be a valid pointer to store the confirmed balance
 - `unconfirmed_out` must be a valid pointer to store the unconfirmed balance
 - `immature_out` must be a valid pointer to store the immature balance
 - `locked_out` must be a valid pointer to store the locked balance
 - `total_out` must be a valid pointer to store the total balance
 - `error` must be a valid pointer to an FFIError
 */

bool managed_wallet_get_balance(const FFIManagedWalletInfo *managed_wallet,
                                uint64_t *confirmed_out,
                                uint64_t *unconfirmed_out,
                                uint64_t *immature_out,
                                uint64_t *locked_out,
                                uint64_t *total_out,
                                FFIError *error)
;

/*
 Get current synced height from wallet info

 # Safety

 - `managed_wallet` must be a valid pointer to an FFIManagedWalletInfo
 - `error` must be a valid pointer to an FFIError structure or null
 - The caller must ensure all pointers remain valid for the duration of this call
 */

unsigned int managed_wallet_synced_height(const FFIManagedWalletInfo *managed_wallet,
                                          FFIError *error)
;

/*
 Free managed wallet info

 # Safety

 - `managed_wallet` must be a valid pointer to an FFIManagedWalletInfo or null
 - After calling this function, the pointer becomes invalid and must not be used
 */
 void managed_wallet_free(FFIManagedWalletInfo *managed_wallet) ;

/*
 Free managed wallet info returned by wallet_manager_get_managed_wallet_info

 # Safety

 - `wallet_info` must be a valid pointer returned by wallet_manager_get_managed_wallet_info or null
 - After calling this function, the pointer becomes invalid and must not be used
 */
 void managed_wallet_info_free(FFIManagedWalletInfo *wallet_info) ;

/*
 Generate a new mnemonic with specified word count (12, 15, 18, 21, or 24)
 */
 char *mnemonic_generate(unsigned int word_count, FFIError *error) ;

/*
 Generate a new mnemonic with specified language and word count
 */

char *mnemonic_generate_with_language(unsigned int word_count,
                                      FFILanguage language,
                                      FFIError *error)
;

/*
 Validate a mnemonic phrase

 # Safety

 - `mnemonic` must be a valid null-terminated C string or null
 - `error` must be a valid pointer to an FFIError
 */
 bool mnemonic_validate(const char *mnemonic, FFIError *error) ;

/*
 Convert mnemonic to seed with optional passphrase

 # Safety

 - `mnemonic` must be a valid null-terminated C string
 - `passphrase` must be a valid null-terminated C string or null
 - `seed_out` must be a valid pointer to a buffer of at least 64 bytes
 - `seed_len` must be a valid pointer to store the seed length
 - `error` must be a valid pointer to an FFIError
 */

bool mnemonic_to_seed(const char *mnemonic,
                      const char *passphrase,
                      uint8_t *seed_out,
                      size_t *seed_len,
                      FFIError *error)
;

/*
 Get word count from mnemonic

 # Safety

 - `mnemonic` must be a valid null-terminated C string or null
 - `error` must be a valid pointer to an FFIError
 */
 unsigned int mnemonic_word_count(const char *mnemonic, FFIError *error) ;

/*
 Free a mnemonic string

 # Safety

 - `mnemonic` must be a valid pointer created by mnemonic generation functions or null
 - After calling this function, the pointer becomes invalid
 */
 void mnemonic_free(char *mnemonic) ;

/*
 Build a transaction (unsigned)

 This creates an unsigned transaction. Use wallet_sign_transaction to sign it afterward.
 For a combined build+sign operation, use wallet_build_and_sign_transaction.

 # Safety

 - `wallet` must be a valid pointer to an FFIWallet
 - `outputs` must be a valid pointer to an array of FFITxOutput with at least `outputs_count` elements
 - `tx_bytes_out` must be a valid pointer to store the transaction bytes pointer
 - `tx_len_out` must be a valid pointer to store the transaction length
 - `error` must be a valid pointer to an FFIError
 - The returned transaction bytes must be freed with `transaction_bytes_free`
 */

bool wallet_build_transaction(FFIWallet *wallet,
                              unsigned int account_index,
                              const FFITxOutput *outputs,
                              size_t outputs_count,
                              uint64_t fee_per_kb,
                              uint8_t **tx_bytes_out,
                              size_t *tx_len_out,
                              FFIError *error)
;

/*
 Sign a transaction

 # Safety

 - `wallet` must be a valid pointer to an FFIWallet
 - `tx_bytes` must be a valid pointer to transaction bytes with at least `tx_len` bytes
 - `signed_tx_out` must be a valid pointer to store the signed transaction bytes pointer
 - `signed_len_out` must be a valid pointer to store the signed transaction length
 - `error` must be a valid pointer to an FFIError
 - The returned signed transaction bytes must be freed with `transaction_bytes_free`
 */

bool wallet_sign_transaction(const FFIWallet *wallet,
                             const uint8_t *tx_bytes,
                             size_t tx_len,
                             uint8_t **signed_tx_out,
                             size_t *signed_len_out,
                             FFIError *error)
;

/*
 Build and sign a transaction using the wallet's managed info

 This is the recommended way to build transactions. It handles:
 - UTXO selection using coin selection algorithms
 - Fee calculation
 - Change address generation
 - Transaction signing

 # Safety

 - `managed_wallet` must be a valid pointer to an FFIManagedWalletInfo
 - `wallet` must be a valid pointer to an FFIWallet
 - `outputs` must be a valid pointer to an array of FFITxOutput with at least `outputs_count` elements
 - `tx_bytes_out` must be a valid pointer to store the transaction bytes pointer
 - `tx_len_out` must be a valid pointer to store the transaction length
 - `error` must be a valid pointer to an FFIError
 - The returned transaction bytes must be freed with `transaction_bytes_free`
 */

bool wallet_build_and_sign_transaction(FFIManagedWalletInfo *managed_wallet,
                                       const FFIWallet *wallet,
                                       unsigned int account_index,
                                       const FFITxOutput *outputs,
                                       size_t outputs_count,
                                       uint64_t fee_per_kb,
                                       uint32_t current_height,
                                       uint8_t **tx_bytes_out,
                                       size_t *tx_len_out,
                                       FFIError *error)
;

/*
 Check if a transaction belongs to the wallet using ManagedWalletInfo

 # Safety

 - `wallet` must be a valid mutable pointer to an FFIWallet
 - `tx_bytes` must be a valid pointer to transaction bytes with at least `tx_len` bytes
 - `inputs_spent_out` must be a valid pointer to store the spent inputs count
 - `addresses_used_out` must be a valid pointer to store the used addresses count
 - `new_balance_out` must be a valid pointer to store the new balance
 - `new_address_out` must be a valid pointer to store the address array pointer
 - `new_address_count_out` must be a valid pointer to store the address count
 - `error` must be a valid pointer to an FFIError
 */

bool wallet_check_transaction(FFIWallet *wallet,
                              const uint8_t *tx_bytes,
                              size_t tx_len,
                              FFITransactionContext context_type,
                              uint32_t block_height,
                              const uint8_t *block_hash,
                              uint64_t timestamp,
                              bool update_state,
                              FFITransactionCheckResult *result_out,
                              FFIError *error)
;

/*
 Free transaction bytes

 # Safety

 - `tx_bytes` must be a valid pointer created by transaction functions or null
 - After calling this function, the pointer becomes invalid
 */
 void transaction_bytes_free(uint8_t *tx_bytes) ;

/*
 Create a new empty transaction

 # Returns
 - Pointer to FFITransaction on success
 - NULL on error
 */
 FFITransaction *transaction_create(void) ;

/*
 Add an input to a transaction

 # Safety
 - `tx` must be a valid pointer to an FFITransaction
 - `input` must be a valid pointer to an FFITxIn

 # Returns
 - 0 on success
 - -1 on error
 */
 int32_t transaction_add_input(FFITransaction *tx, const FFITxIn *input) ;

/*
 Add an output to a transaction

 # Safety
 - `tx` must be a valid pointer to an FFITransaction
 - `output` must be a valid pointer to an FFITxOut

 # Returns
 - 0 on success
 - -1 on error
 */
 int32_t transaction_add_output(FFITransaction *tx, const FFITxOut *output) ;

/*
 Get the transaction ID

 # Safety
 - `tx` must be a valid pointer to an FFITransaction
 - `txid_out` must be a valid pointer to a buffer of at least 32 bytes

 # Returns
 - 0 on success
 - -1 on error
 */
 int32_t transaction_get_txid(const FFITransaction *tx, uint8_t *txid_out) ;

/*
 Get transaction ID from raw transaction bytes

 # Safety
 - `tx_bytes` must be a valid pointer to transaction bytes
 - `tx_len` must be the correct length of the transaction
 - `error` must be a valid pointer to an FFIError

 # Returns
 - Pointer to null-terminated hex string of TXID (must be freed with string_free)
 - NULL on error
 */
 char *transaction_get_txid_from_bytes(const uint8_t *tx_bytes, size_t tx_len, FFIError *error) ;

/*
 Serialize a transaction

 # Safety
 - `tx` must be a valid pointer to an FFITransaction
 - `out_buf` can be NULL to get size only
 - `out_len` must be a valid pointer to store the size

 # Returns
 - 0 on success
 - -1 on error
 */
 int32_t transaction_serialize(const FFITransaction *tx, uint8_t *out_buf, uint32_t *out_len) ;

/*
 Deserialize a transaction

 # Safety
 - `data` must be a valid pointer to serialized transaction data
 - `len` must be the correct length of the data

 # Returns
 - Pointer to FFITransaction on success
 - NULL on error
 */
 FFITransaction *transaction_deserialize(const uint8_t *data, uint32_t len) ;

/*
 Destroy a transaction

 # Safety
 - `tx` must be a valid pointer to an FFITransaction created by transaction functions or null
 - After calling this function, the pointer becomes invalid
 */
 void transaction_destroy(FFITransaction *tx) ;

/*
 Calculate signature hash for an input

 # Safety
 - `tx` must be a valid pointer to an FFITransaction
 - `script_pubkey` must be a valid pointer to the script pubkey
 - `hash_out` must be a valid pointer to a buffer of at least 32 bytes

 # Returns
 - 0 on success
 - -1 on error
 */

int32_t transaction_sighash(const FFITransaction *tx,
                            uint32_t input_index,
                            const uint8_t *script_pubkey,
                            uint32_t script_pubkey_len,
                            uint32_t sighash_type,
                            uint8_t *hash_out)
;

/*
 Sign a transaction input

 # Safety
 - `tx` must be a valid pointer to an FFITransaction
 - `private_key` must be a valid pointer to a 32-byte private key
 - `script_pubkey` must be a valid pointer to the script pubkey

 # Returns
 - 0 on success
 - -1 on error
 */

int32_t transaction_sign_input(FFITransaction *tx,
                               uint32_t input_index,
                               const uint8_t *private_key,
                               const uint8_t *script_pubkey,
                               uint32_t script_pubkey_len,
                               uint32_t sighash_type)
;

/*
 Create a P2PKH script pubkey

 # Safety
 - `pubkey_hash` must be a valid pointer to a 20-byte public key hash
 - `out_buf` can be NULL to get size only
 - `out_len` must be a valid pointer to store the size

 # Returns
 - 0 on success
 - -1 on error
 */
 int32_t script_p2pkh(const uint8_t *pubkey_hash, uint8_t *out_buf, uint32_t *out_len) ;

/*
 Extract public key hash from P2PKH address

 # Safety
 - `address` must be a valid pointer to a null-terminated C string
 - `hash_out` must be a valid pointer to a buffer of at least 20 bytes

 # Returns
 - 0 on success
 - -1 on error
 */
 int32_t address_to_pubkey_hash(const char *address, FFINetwork network, uint8_t *hash_out) ;

/*
 Create a managed wallet from a regular wallet

 This creates a ManagedWalletInfo instance from a Wallet, which includes
 address pools and transaction checking capabilities.

 # Safety

 - `wallet` must be a valid pointer to an FFIWallet
 - `error` must be a valid pointer to an FFIError or null
 - The returned pointer must be freed with `managed_wallet_info_free` (or `ffi_managed_wallet_free` for compatibility)
 */

FFIManagedWalletInfo *wallet_create_managed_wallet(const FFIWallet *wallet,
                                                   FFIError *error)
;

/*
 Check if a transaction belongs to the wallet

 This function checks a transaction against all relevant account types in the wallet
 and returns detailed information about which accounts are affected.

 # Safety

 - `managed_wallet` must be a valid pointer to an FFIManagedWalletInfo
 - `wallet` must be a valid pointer to an FFIWallet (needed for address generation and DashPay queries)
 - `tx_bytes` must be a valid pointer to transaction bytes with at least `tx_len` bytes
 - `result_out` must be a valid pointer to store the result
 - `error` must be a valid pointer to an FFIError
 - The affected_accounts array in the result must be freed with `transaction_check_result_free`
 */

bool managed_wallet_check_transaction(FFIManagedWalletInfo *managed_wallet,
                                      FFIWallet *wallet,
                                      const uint8_t *tx_bytes,
                                      size_t tx_len,
                                      FFITransactionContext context_type,
                                      unsigned int block_height,
                                      const uint8_t *block_hash,
                                      uint64_t timestamp,
                                      bool update_state,
                                      FFITransactionCheckResult *result_out,
                                      FFIError *error)
;

/*
 Free a transaction check result

 # Safety

 - `result` must be a valid pointer to an FFITransactionCheckResult
 - This function must only be called once per result
 */
 void transaction_check_result_free(FFITransactionCheckResult *result) ;

/*
 Free a managed wallet (FFIManagedWalletInfo type)

 # Safety

 - `managed_wallet` must be a valid pointer to an FFIManagedWalletInfo
 - This function must only be called once per managed wallet
 */
 void ffi_managed_wallet_free(FFIManagedWalletInfo *managed_wallet) ;

/*
 Get the transaction classification for routing

 Returns a string describing the transaction type (e.g., "Standard", "CoinJoin",
 "AssetLock", "AssetUnlock", "ProviderRegistration", etc.)

 # Safety

 - `tx_bytes` must be a valid pointer to transaction bytes with at least `tx_len` bytes
 - `error` must be a valid pointer to an FFIError or null
 - The returned string must be freed by the caller
 */
 char *transaction_classify(const uint8_t *tx_bytes, size_t tx_len, FFIError *error) ;

 const char *ffi_network_get_name(FFINetwork network) ;

/*
 Free a string

 # Safety

 - `s` must be a valid pointer created by C string creation functions or null
 - After calling this function, the pointer becomes invalid
 */
 void string_free(char *s) ;

/*
 Get all UTXOs from managed wallet info

 # Safety

 - `managed_info` must be a valid pointer to an FFIManagedWalletInfo instance
 - `utxos_out` must be a valid pointer to store the UTXO array pointer
 - `count_out` must be a valid pointer to store the UTXO count
 - `error` must be a valid pointer to an FFIError structure or null
 - The caller must ensure all pointers remain valid for the duration of this call
 - The returned UTXO array must be freed with `utxo_array_free` when no longer needed
 */

bool managed_wallet_get_utxos(const FFIManagedWalletInfo *managed_info,
                              FFIUTXO **utxos_out,
                              size_t *count_out,
                              FFIError *error)
;

/*
 Get all UTXOs (deprecated - use managed_wallet_get_utxos instead)

 # Safety

 This function is deprecated and returns an empty list.
 Use `managed_wallet_get_utxos` with a ManagedWalletInfo instead.
 */

bool wallet_get_utxos(const FFIWallet *_wallet,
                      FFIUTXO **utxos_out,
                      size_t *count_out,
                      FFIError *error)
;

/*
 Free UTXO array

 # Safety

 - `utxos` must be a valid pointer to an array of FFIUTXO structs allocated by this library
 - `count` must match the number of UTXOs in the array
 - The pointer must not be used after calling this function
 - This function must only be called once per array
 */
 void utxo_array_free(FFIUTXO *utxos, size_t count) ;

/*
 Create a new wallet from mnemonic with options

 # Safety

 - `mnemonic` must be a valid pointer to a null-terminated C string
 - `passphrase` must be a valid pointer to a null-terminated C string or null
 - `account_options` must be a valid pointer to FFIWalletAccountCreationOptions or null
 - `error` must be a valid pointer to an FFIError structure or null
 - The caller must ensure all pointers remain valid for the duration of this call
 - The returned pointer must be freed with `wallet_free` when no longer needed
 */

FFIWallet *wallet_create_from_mnemonic_with_options(const char *mnemonic,
                                                    const char *passphrase,
                                                    FFINetwork network,
                                                    const FFIWalletAccountCreationOptions *account_options,
                                                    FFIError *error)
;

/*
 Create a new wallet from mnemonic (backward compatibility - single network)

 # Safety

 - `mnemonic` must be a valid pointer to a null-terminated C string
 - `passphrase` must be a valid pointer to a null-terminated C string or null
 - `error` must be a valid pointer to an FFIError structure or null
 - The caller must ensure all pointers remain valid for the duration of this call
 - The returned pointer must be freed with `wallet_free` when no longer needed
 */

FFIWallet *wallet_create_from_mnemonic(const char *mnemonic,
                                       const char *passphrase,
                                       FFINetwork network,
                                       FFIError *error)
;

/*
 Create a new wallet from seed with options

 # Safety

 - `seed` must be a valid pointer to a byte array of `seed_len` length
 - `account_options` must be a valid pointer to FFIWalletAccountCreationOptions or null
 - `error` must be a valid pointer to an FFIError structure or null
 - The caller must ensure all pointers remain valid for the duration of this call
 */

FFIWallet *wallet_create_from_seed_with_options(const uint8_t *seed,
                                                size_t seed_len,
                                                FFINetwork network,
                                                const FFIWalletAccountCreationOptions *account_options,
                                                FFIError *error)
;

/*
 Create a new wallet from seed (backward compatibility)

 # Safety

 - `seed` must be a valid pointer to a byte array of `seed_len` length
 - `error` must be a valid pointer to an FFIError structure or null
 - The caller must ensure all pointers remain valid for the duration of this call
 */

FFIWallet *wallet_create_from_seed(const uint8_t *seed,
                                   size_t seed_len,
                                   FFINetwork network,
                                   FFIError *error)
;

/*
 Create a new random wallet with options

 # Safety

 - `account_options` must be a valid pointer to FFIWalletAccountCreationOptions or null
 - `error` must be a valid pointer to an FFIError structure or null
 - The caller must ensure all pointers remain valid for the duration of this call
 */

FFIWallet *wallet_create_random_with_options(FFINetwork network,
                                             const FFIWalletAccountCreationOptions *account_options,
                                             FFIError *error)
;

/*
 Create a new random wallet (backward compatibility)

 # Safety

 - `error` must be a valid pointer to an FFIError structure or null
 - The caller must ensure the pointer remains valid for the duration of this call
 */
 FFIWallet *wallet_create_random(FFINetwork network, FFIError *error) ;

/*
 Get wallet ID (32-byte hash)

 # Safety

 - `wallet` must be a valid pointer to an FFIWallet
 - `id_out` must be a valid pointer to a 32-byte buffer
 - `error` must be a valid pointer to an FFIError structure or null
 - The caller must ensure all pointers remain valid for the duration of this call
 */
 bool wallet_get_id(const FFIWallet *wallet, uint8_t *id_out, FFIError *error) ;

/*
 Check if wallet has mnemonic

 # Safety

 - `wallet` must be a valid pointer to an FFIWallet instance
 - `error` must be a valid pointer to an FFIError structure or null
 - The caller must ensure all pointers remain valid for the duration of this call
 */
 bool wallet_has_mnemonic(const FFIWallet *wallet, FFIError *error) ;

/*
 Check if wallet is watch-only

 # Safety

 - `wallet` must be a valid pointer to an FFIWallet instance
 - `error` must be a valid pointer to an FFIError structure or null
 - The caller must ensure all pointers remain valid for the duration of this call
 */
 bool wallet_is_watch_only(const FFIWallet *wallet, FFIError *error) ;

/*
 Get extended public key for account

 # Safety

 - `wallet` must be a valid pointer to an FFIWallet instance
 - `error` must be a valid pointer to an FFIError structure or null
 - The caller must ensure all pointers remain valid for the duration of this call
 - The returned C string must be freed by the caller when no longer needed
 */
 char *wallet_get_xpub(const FFIWallet *wallet, unsigned int account_index, FFIError *error) ;

/*
 Free a wallet

 # Safety

 - `wallet` must be a valid pointer to an FFIWallet that was created by this library
 - The pointer must not be used after calling this function
 - This function must only be called once per wallet
 */
 void wallet_free(FFIWallet *wallet) ;

/*
 Free a const wallet handle

 This is a const-safe wrapper for wallet_free() that accepts a const pointer.
 Use this function when you have a *const FFIWallet that needs to be freed,
 such as wallets returned from wallet_manager_get_wallet().

 # Safety

 - `wallet` must be a valid pointer created by wallet creation functions or null
 - After calling this function, the pointer becomes invalid
 - This function must only be called once per wallet
 - The wallet must have been allocated by this library (not stack or static memory)
 */
 void wallet_free_const(const FFIWallet *wallet) ;

/*
 Add an account to the wallet without xpub

 # Safety

 This function dereferences a raw pointer to FFIWallet.
 The caller must ensure that:
 - The wallet pointer is either null or points to a valid FFIWallet
 - The FFIWallet remains valid for the duration of this call

 # Note

 This function does NOT support the following account types:
 - `PlatformPayment`: Use `wallet_add_platform_payment_account()` instead
 - `DashpayReceivingFunds`: Use `wallet_add_dashpay_receiving_account()` instead
 - `DashpayExternalAccount`: Use `wallet_add_dashpay_external_account_with_xpub_bytes()` instead
 */

FFIAccountResult wallet_add_account(FFIWallet *wallet,
                                    FFIAccountType account_type,
                                    unsigned int account_index)
;

/*
 Add a DashPay receiving funds account

 # Safety
 - `wallet` must be a valid pointer
 - `user_identity_id` and `friend_identity_id` must each point to 32 bytes
 */

FFIAccountResult wallet_add_dashpay_receiving_account(FFIWallet *wallet,
                                                      unsigned int account_index,
                                                      const uint8_t *user_identity_id,
                                                      const uint8_t *friend_identity_id)
;

/*
 Add a DashPay external (watch-only) account with xpub bytes

 # Safety
 - `wallet` must be valid, `xpub_bytes` must point to `xpub_len` bytes
 - `user_identity_id` and `friend_identity_id` must each point to 32 bytes
 */

FFIAccountResult wallet_add_dashpay_external_account_with_xpub_bytes(FFIWallet *wallet,
                                                                     unsigned int account_index,
                                                                     const uint8_t *user_identity_id,
                                                                     const uint8_t *friend_identity_id,
                                                                     const uint8_t *xpub_bytes,
                                                                     size_t xpub_len)
;

/*
 Add an account to the wallet with xpub as byte array

 # Safety

 This function dereferences raw pointers.
 The caller must ensure that:
 - The wallet pointer is either null or points to a valid FFIWallet
 - The xpub_bytes pointer is either null or points to at least xpub_len bytes
 - The FFIWallet remains valid for the duration of this call

 # Note

 This function does NOT support the following account types:
 - `PlatformPayment`: Use `wallet_add_platform_payment_account()` instead
 - `DashpayReceivingFunds`: Use `wallet_add_dashpay_receiving_account()` instead
 - `DashpayExternalAccount`: Use `wallet_add_dashpay_external_account_with_xpub_bytes()` instead
 */

FFIAccountResult wallet_add_account_with_xpub_bytes(FFIWallet *wallet,
                                                    FFIAccountType account_type,
                                                    unsigned int account_index,
                                                    const uint8_t *xpub_bytes,
                                                    size_t xpub_len)
;

/*
 Add an account to the wallet with xpub as string

 # Safety

 This function dereferences raw pointers.
 The caller must ensure that:
 - The wallet pointer is either null or points to a valid FFIWallet
 - The xpub_string pointer is either null or points to a valid null-terminated C string
 - The FFIWallet remains valid for the duration of this call

 # Note

 This function does NOT support the following account types:
 - `PlatformPayment`: Use `wallet_add_platform_payment_account()` instead
 - `DashpayReceivingFunds`: Use `wallet_add_dashpay_receiving_account()` instead
 - `DashpayExternalAccount`: Use `wallet_add_dashpay_external_account_with_xpub_bytes()` instead
 */

FFIAccountResult wallet_add_account_with_string_xpub(FFIWallet *wallet,
                                                     FFIAccountType account_type,
                                                     unsigned int account_index,
                                                     const char *xpub_string)
;

/*
 Add a Platform Payment account (DIP-17) to the wallet

 Platform Payment accounts use the derivation path:
 `m/9'/coin_type'/17'/account'/key_class'/index`

 # Arguments
 * `wallet` - Pointer to the wallet
 * `account_index` - The account index (hardened) in the derivation path
 * `key_class` - The key class (hardened) - typically 0' for main addresses

 # Safety

 This function dereferences a raw pointer to FFIWallet.
 The caller must ensure that:
 - The wallet pointer is either null or points to a valid FFIWallet
 - The FFIWallet remains valid for the duration of this call
 */

FFIAccountResult wallet_add_platform_payment_account(FFIWallet *wallet,
                                                     unsigned int account_index,
                                                     unsigned int key_class)
;

/*
 Describe the wallet manager for a given network and return a newly
 allocated C string.

 # Safety
 - `manager` must be a valid pointer to an `FFIWalletManager`
 - Callers must free the returned string with `wallet_manager_free_string`
 */
 char *wallet_manager_describe(const FFIWalletManager *manager, FFIError *error) ;

/*
 Free a string previously returned by wallet manager APIs.

 # Safety
 - `value` must be either null or a pointer obtained from
   `wallet_manager_describe` (or other wallet manager FFI helpers that
   specify this free function).
 - The pointer must not be used after this call returns.
 */
 void wallet_manager_free_string(char *value) ;

/*
 Create a new wallet manager
 */
 FFIWalletManager *wallet_manager_create(FFINetwork network, FFIError *error) ;

/*
 Add a wallet from mnemonic to the manager with options

 # Safety

 - `manager` must be a valid pointer to an FFIWalletManager instance
 - `mnemonic` must be a valid pointer to a null-terminated C string
 - `passphrase` must be a valid pointer to a null-terminated C string or null
 - `account_options` must be a valid pointer to FFIWalletAccountCreationOptions or null
 - `error` must be a valid pointer to an FFIError structure or null
 - The caller must ensure all pointers remain valid for the duration of this call
 */

bool wallet_manager_add_wallet_from_mnemonic_with_options(FFIWalletManager *manager,
                                                          const char *mnemonic,
                                                          const char *passphrase,
                                                          const FFIWalletAccountCreationOptions *account_options,
                                                          FFIError *error)
;

/*
 Add a wallet from mnemonic to the manager (backward compatibility)

 # Safety

 - `manager` must be a valid pointer to an FFIWalletManager instance
 - `mnemonic` must be a valid pointer to a null-terminated C string
 - `passphrase` must be a valid pointer to a null-terminated C string or null
 - `error` must be a valid pointer to an FFIError structure or null
 - The caller must ensure all pointers remain valid for the duration of this call
 */

bool wallet_manager_add_wallet_from_mnemonic(FFIWalletManager *manager,
                                             const char *mnemonic,
                                             const char *passphrase,
                                             FFIError *error)
;

/*
 Add a wallet from mnemonic to the manager and return serialized bytes

 Creates a wallet from a mnemonic phrase, adds it to the manager, optionally downgrading it
 to a pubkey-only wallet (watch-only or externally signable), and returns the serialized wallet bytes.

 # Safety

 - `manager` must be a valid pointer to an FFIWalletManager instance
 - `mnemonic` must be a valid pointer to a null-terminated C string
 - `passphrase` must be a valid pointer to a null-terminated C string or null
 - `birth_height` is the block height to start syncing from (0 = sync from genesis)
 - `account_options` must be a valid pointer to FFIWalletAccountCreationOptions or null
 - `downgrade_to_pubkey_wallet` if true, creates a watch-only or externally signable wallet
 - `allow_external_signing` if true AND downgrade_to_pubkey_wallet is true, creates an externally signable wallet
 - `wallet_bytes_out` must be a valid pointer to a pointer that will receive the serialized bytes
 - `wallet_bytes_len_out` must be a valid pointer that will receive the byte length
 - `wallet_id_out` must be a valid pointer to a 32-byte array that will receive the wallet ID
 - `error` must be a valid pointer to an FFIError structure or null
 - The caller must ensure all pointers remain valid for the duration of this call
 - The caller must free the returned wallet_bytes using wallet_manager_free_wallet_bytes()
 */

bool wallet_manager_add_wallet_from_mnemonic_return_serialized_bytes(FFIWalletManager *manager,
                                                                     const char *mnemonic,
                                                                     const char *passphrase,
                                                                     unsigned int birth_height,
                                                                     const FFIWalletAccountCreationOptions *account_options,
                                                                     bool downgrade_to_pubkey_wallet,
                                                                     bool allow_external_signing,
                                                                     uint8_t **wallet_bytes_out,
                                                                     size_t *wallet_bytes_len_out,
                                                                     uint8_t *wallet_id_out,
                                                                     FFIError *error)
;

/*
 Free wallet bytes buffer

 # Safety

 - `wallet_bytes` must be a valid pointer to a buffer allocated by wallet_manager_add_wallet_from_mnemonic_return_serialized_bytes
 - `bytes_len` must match the original allocation size
 - The pointer must not be used after calling this function
 - This function must only be called once per buffer
 */

void wallet_manager_free_wallet_bytes(uint8_t *wallet_bytes,
                                      size_t bytes_len)
;

/*
 Import a wallet from bincode-serialized bytes

 Deserializes a wallet from bytes and adds it to the manager.
 Returns a 32-byte wallet ID on success.

 # Safety

 - `manager` must be a valid pointer to an FFIWalletManager instance
 - `wallet_bytes` must be a valid pointer to bincode-serialized wallet bytes
 - `wallet_bytes_len` must be the exact length of the wallet bytes
 - `wallet_id_out` must be a valid pointer to a 32-byte array that will receive the wallet ID
 - `error` must be a valid pointer to an FFIError structure or null
 - The caller must ensure all pointers remain valid for the duration of this call
 */

bool wallet_manager_import_wallet_from_bytes(FFIWalletManager *manager,
                                             const uint8_t *wallet_bytes,
                                             size_t wallet_bytes_len,
                                             uint8_t *wallet_id_out,
                                             FFIError *error)
;

/*
 Get wallet IDs

 # Safety

 - `manager` must be a valid pointer to an FFIWalletManager
 - `wallet_ids_out` must be a valid pointer to a pointer that will receive the wallet IDs
 - `count_out` must be a valid pointer to receive the count
 - `error` must be a valid pointer to an FFIError structure or null
 - The caller must ensure all pointers remain valid for the duration of this call
 */

bool wallet_manager_get_wallet_ids(const FFIWalletManager *manager,
                                   uint8_t **wallet_ids_out,
                                   size_t *count_out,
                                   FFIError *error)
;

/*
 Get a wallet from the manager

 Returns a reference to the wallet if found

 # Safety

 - `manager` must be a valid pointer to an FFIWalletManager instance
 - `wallet_id` must be a valid pointer to a 32-byte wallet ID
 - `error` must be a valid pointer to an FFIError structure or null
 - The caller must ensure all pointers remain valid for the duration of this call
 - The returned wallet must be freed with wallet_free_const()
 */

const FFIWallet *wallet_manager_get_wallet(const FFIWalletManager *manager,
                                           const uint8_t *wallet_id,
                                           FFIError *error)
;

/*
 Get managed wallet info from the manager

 Returns a reference to the managed wallet info if found

 # Safety

 - `manager` must be a valid pointer to an FFIWalletManager instance
 - `wallet_id` must be a valid pointer to a 32-byte wallet ID
 - `error` must be a valid pointer to an FFIError structure or null
 - The caller must ensure all pointers remain valid for the duration of this call
 - The returned managed wallet info must be freed with managed_wallet_info_free()
 */

FFIManagedWalletInfo *wallet_manager_get_managed_wallet_info(const FFIWalletManager *manager,
                                                             const uint8_t *wallet_id,
                                                             FFIError *error)
;

/*
 Get wallet balance

 Returns the confirmed and unconfirmed balance for a specific wallet

 # Safety

 - `manager` must be a valid pointer to an FFIWalletManager instance
 - `wallet_id` must be a valid pointer to a 32-byte wallet ID
 - `confirmed_out` must be a valid pointer to a u64 (maps to C uint64_t)
 - `unconfirmed_out` must be a valid pointer to a u64 (maps to C uint64_t)
 - `error` must be a valid pointer to an FFIError structure or null
 - The caller must ensure all pointers remain valid for the duration of this call
 */

bool wallet_manager_get_wallet_balance(const FFIWalletManager *manager,
                                       const uint8_t *wallet_id,
                                       uint64_t *confirmed_out,
                                       uint64_t *unconfirmed_out,
                                       FFIError *error)
;

/*
 Process a transaction through all wallets

 Checks a transaction against all wallets and updates their states if relevant.
 Returns true if the transaction was relevant to at least one wallet.

 # Safety

 - `manager` must be a valid pointer to an FFIWalletManager instance
 - `tx_bytes` must be a valid pointer to transaction bytes
 - `tx_len` must be the length of the transaction bytes
 - `context` must be a valid pointer to FFITransactionContextDetails
 - `update_state_if_found` indicates whether to update wallet state when transaction is relevant
 - `error` must be a valid pointer to an FFIError structure or null
 - The caller must ensure all pointers remain valid for the duration of this call
 */

bool wallet_manager_process_transaction(FFIWalletManager *manager,
                                        const uint8_t *tx_bytes,
                                        size_t tx_len,
                                        const FFITransactionContextDetails *context,
                                        bool update_state_if_found,
                                        FFIError *error)
;

/*
 Get the network for this wallet manager

 # Safety

 - `manager` must be a valid pointer to an FFIWalletManager
 - `error` must be a valid pointer to an FFIError structure or null
 - The caller must ensure all pointers remain valid for the duration of this call
 */
 FFINetwork wallet_manager_network(const FFIWalletManager *manager, FFIError *error) ;

/*
 Get current height for a network

 # Safety

 - `manager` must be a valid pointer to an FFIWalletManager
 - `error` must be a valid pointer to an FFIError structure or null
 - The caller must ensure all pointers remain valid for the duration of this call
 */
 unsigned int wallet_manager_current_height(const FFIWalletManager *manager, FFIError *error) ;

/*
 Get wallet count

 # Safety

 - `manager` must be a valid pointer to an FFIWalletManager instance
 - `error` must be a valid pointer to an FFIError structure or null
 - The caller must ensure all pointers remain valid for the duration of this call
 */
 size_t wallet_manager_wallet_count(const FFIWalletManager *manager, FFIError *error) ;

/*
 Free wallet manager

 # Safety

 - `manager` must be a valid pointer to an FFIWalletManager that was created by this library
 - The pointer must not be used after calling this function
 - This function must only be called once per manager
 */
 void wallet_manager_free(FFIWalletManager *manager) ;

/*
 Free wallet IDs buffer

 # Safety

 - `wallet_ids` must be a valid pointer to a buffer allocated by this library
 - `count` must match the number of wallet IDs in the buffer
 - The pointer must not be used after calling this function
 - This function must only be called once per buffer
 */
 void wallet_manager_free_wallet_ids(uint8_t *wallet_ids, size_t count) ;

/*
 Free address array

 # Safety

 - `addresses` must be a valid pointer to an array of C string pointers allocated by this library
 - `count` must match the original allocation size
 - Each address pointer in the array must be either null or a valid C string allocated by this library
 - The pointers must not be used after calling this function
 - This function must only be called once per allocation
 */

void wallet_manager_free_addresses(char **addresses,
                                   size_t count)
;

/*
 Encrypt a private key with BIP38

 # Safety

 This function is unsafe because it dereferences raw pointers:
 - `private_key` must be a valid, null-terminated C string
 - `passphrase` must be a valid, null-terminated C string
 - `error` must be a valid pointer to an FFIError or null
 */
 char *bip38_encrypt_private_key(const char *private_key, const char *passphrase, FFIError *error) ;

/*
 Decrypt a BIP38 encrypted private key

 # Safety

 This function is unsafe because it dereferences raw pointers:
 - `encrypted_key` must be a valid, null-terminated C string
 - `passphrase` must be a valid, null-terminated C string
 - `error` must be a valid pointer to an FFIError or null
 */

char *bip38_decrypt_private_key(const char *encrypted_key,
                                const char *passphrase,
                                FFIError *error)
;

#ifdef __cplusplus
}  // extern "C"
#endif  // __cplusplus

#endif  /* KEY_WALLET_FFI_H */
