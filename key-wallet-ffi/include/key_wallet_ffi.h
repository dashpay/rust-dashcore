/**
 * Key Wallet FFI - C Header File
 * 
 * This header provides C-compatible function declarations for the key-wallet
 * Rust library FFI bindings.
 * 
 * AUTO-GENERATED FILE - DO NOT EDIT
 * Generated using cbindgen
 */

#ifndef KEY_WALLET_FFI_H
#define KEY_WALLET_FFI_H

/* Generated with cbindgen:0.29.0 */

/* Warning: This file is auto-generated by cbindgen. Do not modify manually. */

#include <stdarg.h>
#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>
#include <stdlib.h>
#include <stdint.h>
#include <stddef.h>
#include <stdbool.h>

/*
 FFI Account Creation Option Type
 */
typedef enum {
    /*
     Create default accounts (BIP44 account 0, CoinJoin account 0, and special accounts)
     */
    DEFAULT = 0,
    /*
     Create all specified accounts plus all special purpose accounts
     */
    ALL_ACCOUNTS = 1,
    /*
     Create only BIP44 accounts (no CoinJoin or special accounts)
     */
    BIP44_ACCOUNTS_ONLY = 2,
    /*
     Create specific accounts with full control
     */
    SPECIFIC_ACCOUNTS = 3,
    /*
     Create no accounts at all
     */
    NONE = 4,
} FFIAccountCreationOptionType;

/*
 Account type enumeration matching all key_wallet AccountType variants

 This enum provides a complete FFI representation of all account types
 supported by the key_wallet library:

 - Standard accounts: BIP44 and BIP32 variants for regular transactions
 - CoinJoin: Privacy-enhanced transactions
 - Identity accounts: Registration, top-up, and invitation funding
 - Provider accounts: Various masternode provider key types (voting, owner, operator, platform)
 */
typedef enum {
    /*
     Standard BIP44 account (m/44'/coin_type'/account'/x/x)
     */
    STANDARD_BIP44 = 0,
    /*
     Standard BIP32 account (m/account'/x/x)
     */
    STANDARD_BIP32 = 1,
    /*
     CoinJoin account for private transactions
     */
    COIN_JOIN = 2,
    /*
     Identity registration funding
     */
    IDENTITY_REGISTRATION = 3,
    /*
     Identity top-up funding (requires registration_index)
     */
    IDENTITY_TOP_UP = 4,
    /*
     Identity top-up funding not bound to a specific identity
     */
    IDENTITY_TOP_UP_NOT_BOUND_TO_IDENTITY = 5,
    /*
     Identity invitation funding
     */
    IDENTITY_INVITATION = 6,
    /*
     Provider voting keys (DIP-3) - Path: m/9'/5'/3'/1'/[key_index]
     */
    PROVIDER_VOTING_KEYS = 7,
    /*
     Provider owner keys (DIP-3) - Path: m/9'/5'/3'/2'/[key_index]
     */
    PROVIDER_OWNER_KEYS = 8,
    /*
     Provider operator keys (DIP-3) - Path: m/9'/5'/3'/3'/[key_index]
     */
    PROVIDER_OPERATOR_KEYS = 9,
    /*
     Provider platform P2P keys (DIP-3, ED25519) - Path: m/9'/5'/3'/4'/[key_index]
     */
    PROVIDER_PLATFORM_KEYS = 10,
} FFIAccountType;

/*
 Derivation path type for DIP9
 */
typedef enum {
    UNKNOWN = 0,
    BIP32 = 1,
    BIP44 = 2,
    BLOCKCHAIN_IDENTITIES = 3,
    PROVIDER_FUNDS = 4,
    PROVIDER_VOTING_KEYS = 5,
    PROVIDER_OPERATOR_KEYS = 6,
    PROVIDER_OWNER_KEYS = 7,
    CONTACT_BASED_FUNDS = 8,
    CONTACT_BASED_FUNDS_ROOT = 9,
    CONTACT_BASED_FUNDS_EXTERNAL = 10,
    BLOCKCHAIN_IDENTITY_CREDIT_REGISTRATION_FUNDING = 11,
    BLOCKCHAIN_IDENTITY_CREDIT_TOPUP_FUNDING = 12,
    BLOCKCHAIN_IDENTITY_CREDIT_INVITATION_FUNDING = 13,
    PROVIDER_PLATFORM_NODE_KEYS = 14,
    COIN_JOIN = 15,
    ROOT = 255,
} FFIDerivationPathType;

/*
 FFI Error code
 */
typedef enum {
    SUCCESS = 0,
    INVALID_INPUT = 1,
    ALLOCATION_FAILED = 2,
    INVALID_MNEMONIC = 3,
    INVALID_DERIVATION_PATH = 4,
    INVALID_NETWORK = 5,
    INVALID_ADDRESS = 6,
    INVALID_TRANSACTION = 7,
    WALLET_ERROR = 8,
    SERIALIZATION_ERROR = 9,
    NOT_FOUND = 10,
    INVALID_STATE = 11,
} FFIErrorCode;

/*
 Language enumeration for mnemonic generation

 This enum must be kept in sync with key_wallet::mnemonic::Language.
 When adding new languages to the key_wallet crate, remember to update
 this FFI enum and both From implementations below.
 */
typedef enum {
    ENGLISH = 0,
    CHINESE_SIMPLIFIED = 1,
    CHINESE_TRADITIONAL = 2,
    CZECH = 3,
    FRENCH = 4,
    ITALIAN = 5,
    JAPANESE = 6,
    KOREAN = 7,
    PORTUGUESE = 8,
    SPANISH = 9,
} FFILanguage;

/*
 FFI Network type
 */
typedef enum {
    DASH = 0,
    TESTNET = 1,
    REGTEST = 2,
    DEVNET = 3,
} FFINetwork;

/*
 Transaction context for checking
 */
typedef enum {
    /*
     Transaction is in mempool (unconfirmed)
     */
    MEMPOOL = 0,
    /*
     Transaction is in a block
     */
    IN_BLOCK = 1,
    /*
     Transaction is in a chain-locked block
     */
    IN_CHAIN_LOCKED_BLOCK = 2,
} FFITransactionContext;

/*
 Opaque account handle
 */
typedef struct FFIAccount FFIAccount;

/*
 Extended private key structure
 */
typedef struct FFIExtendedPrivKey FFIExtendedPrivKey;

/*
 Opaque type for an extended private key
 */
typedef struct FFIExtendedPrivateKey FFIExtendedPrivateKey;

/*
 Extended public key structure
 */
typedef struct FFIExtendedPubKey FFIExtendedPubKey;

/*
 Opaque type for an extended public key
 */
typedef struct FFIExtendedPublicKey FFIExtendedPublicKey;

/*
 FFI wrapper for ManagedWalletInfo
 */
typedef struct FFIManagedWalletInfo FFIManagedWalletInfo;

/*
 Opaque type for a private key (SecretKey)
 */
typedef struct FFIPrivateKey FFIPrivateKey;

/*
 Opaque type for a public key
 */
typedef struct FFIPublicKey FFIPublicKey;

/*
 Opaque wallet handle
 */
typedef struct FFIWallet FFIWallet;

/*
 FFI wrapper for WalletManager
 */
typedef struct FFIWalletManager FFIWalletManager;

/*
 FFI Result type for Account operations
 */
typedef struct {
    /*
     The account handle if successful, NULL if error
     */
    FFIAccount *account;
    /*
     Error code (0 = success)
     */
    int32_t error_code;
    /*
     Error message (NULL if success, must be freed by caller if not NULL)
     */
    char *error_message;
} FFIAccountResult;

/*
 FFI Error structure
 */
typedef struct {
    FFIErrorCode code;
    char *message;
} FFIError;

/*
 Balance structure for FFI
 */
typedef struct {
    uint64_t confirmed;
    uint64_t unconfirmed;
    uint64_t immature;
    uint64_t total;
} FFIBalance;

/*
 Transaction output for building
 */
typedef struct {
    const char *address;
    uint64_t amount;
} FFITxOutput;

/*
 Transaction check result
 */
typedef struct {
    /*
     Whether the transaction belongs to the wallet
     */
    bool is_relevant;
    /*
     Total amount received
     */
    uint64_t total_received;
    /*
     Total amount sent
     */
    uint64_t total_sent;
    /*
     Number of affected accounts
     */
    uint32_t affected_accounts_count;
} FFITransactionCheckResult;

/*
 UTXO structure for FFI
 */
typedef struct {
    uint8_t txid[32];
    uint32_t vout;
    uint64_t amount;
    char *address;
    uint8_t *script_pubkey;
    size_t script_len;
    uint32_t height;
    uint32_t confirmations;
} FFIUTXO;

/*
 FFI structure for wallet account creation options
 This single struct represents all possible account creation configurations
 */
typedef struct {
    /*
     The type of account creation option
     */
    FFIAccountCreationOptionType option_type;
    /*
     Array of BIP44 account indices to create
     */
    const uint32_t *bip44_indices;
    size_t bip44_count;
    /*
     Array of BIP32 account indices to create
     */
    const uint32_t *bip32_indices;
    size_t bip32_count;
    /*
     Array of CoinJoin account indices to create
     */
    const uint32_t *coinjoin_indices;
    size_t coinjoin_count;
    /*
     Array of identity top-up registration indices to create
     */
    const uint32_t *topup_indices;
    size_t topup_count;
    /*
     For SpecificAccounts: Additional special account types to create
     (e.g., IdentityRegistration, ProviderKeys, etc.)
     This is an array of FFIAccountType values
     */
    const FFIAccountType *special_account_types;
    size_t special_account_types_count;
} FFIWalletAccountCreationOptions;

/*
 FFI-compatible transaction context details
 */
typedef struct {
    /*
     The context type
     */
    FFITransactionContext context_type;
    /*
     Block height (0 for mempool)
     */
    unsigned int height;
    /*
     Block hash (32 bytes, null for mempool or if unknown)
     */
    const uint8_t *block_hash;
    /*
     Timestamp (0 if unknown)
     */
    unsigned int timestamp;
} FFITransactionContextDetails;

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

/*
 Initialize the library
 */
 bool key_wallet_ffi_initialize(void) ;

/*
 Get library version

 Returns a static string that should NOT be freed by the caller
 */
 const char *key_wallet_ffi_version(void) ;

/*
 Get an account handle for a specific account type
 Returns a result containing either the account handle or an error

 # Safety

 - `wallet` must be a valid pointer to an FFIWallet instance
 - The caller must ensure the wallet pointer remains valid for the duration of this call
 */

FFIAccountResult wallet_get_account(const FFIWallet *wallet,
                                    FFINetwork network,
                                    unsigned int account_index,
                                    unsigned int account_type)
;

/*
 Get an IdentityTopUp account handle with a specific registration index
 This is used for top-up accounts that are bound to a specific identity
 Returns a result containing either the account handle or an error

 # Safety

 - `wallet` must be a valid pointer to an FFIWallet instance
 - The caller must ensure the wallet pointer remains valid for the duration of this call
 */

FFIAccountResult wallet_get_top_up_account_with_registration_index(const FFIWallet *wallet,
                                                                   FFINetwork network,
                                                                   unsigned int registration_index)
;

/*
 Free an account handle

 # Safety

 - `account` must be a valid pointer to an FFIAccount that was allocated by this library
 - The pointer must not be used after calling this function
 - This function must only be called once per allocation
 */
 void account_free(FFIAccount *account) ;

/*
 Free an account result's error message (if any)
 Note: This does NOT free the account handle itself - use account_free for that

 # Safety

 - `result` must be a valid pointer to an FFIAccountResult
 - The error_message field must be either null or a valid CString allocated by this library
 - The caller must ensure the result pointer remains valid for the duration of this call
 */
 void account_result_free_error(FFIAccountResult *result) ;

/*
 Get number of accounts

 # Safety

 - `wallet` must be a valid pointer to an FFIWallet instance
 - `error` must be a valid pointer to an FFIError structure or null
 - The caller must ensure both pointers remain valid for the duration of this call
 */

unsigned int wallet_get_account_count(const FFIWallet *wallet,
                                      FFINetwork network,
                                      FFIError *error)
;

/*
 Free address string

 # Safety

 - `address` must be a valid pointer created by address functions or null
 - After calling this function, the pointer becomes invalid
 */
 void address_free(char *address) ;

/*
 Free address array

 # Safety

 - `addresses` must be a valid pointer to an array of address strings or null
 - Each address in the array must be a valid C string pointer
 - `count` must be the correct number of addresses in the array
 - After calling this function, all pointers become invalid
 */
 void address_array_free(char **addresses, size_t count) ;

/*
 Validate an address

 # Safety

 - `address` must be a valid null-terminated C string
 - `error` must be a valid pointer to an FFIError
 */
 bool address_validate(const char *address, FFINetwork network, FFIError *error) ;

/*
 Get address type

 Returns:
 - 0: P2PKH address
 - 1: P2SH address
 - 2: Other address type
 - u8::MAX (255): Error occurred

 # Safety

 - `address` must be a valid null-terminated C string
 - `error` must be a valid pointer to an FFIError
 */
 unsigned char address_get_type(const char *address, FFINetwork network, FFIError *error) ;

/*
 Get wallet balance

 # Safety

 - `wallet` must be a valid pointer to an FFIWallet instance
 - `balance_out` must be a valid pointer to an FFIBalance structure
 - `error` must be a valid pointer to an FFIError structure or null
 - The caller must ensure all pointers remain valid for the duration of this call
 */

bool wallet_get_balance(const FFIWallet *wallet,
                        FFINetwork network,
                        FFIBalance *balance_out,
                        FFIError *error)
;

/*
 Get account balance

 # Safety

 - `wallet` must be a valid pointer to an FFIWallet instance
 - `balance_out` must be a valid pointer to an FFIBalance structure
 - `error` must be a valid pointer to an FFIError structure or null
 - The caller must ensure all pointers remain valid for the duration of this call
 */

bool wallet_get_account_balance(const FFIWallet *wallet,
                                FFINetwork network,
                                unsigned int account_index,
                                FFIBalance *balance_out,
                                FFIError *error)
;

/*
 Create a new master extended private key from seed

 # Safety

 - `seed` must be a valid pointer to a byte array of `seed_len` length
 - `error` must be a valid pointer to an FFIError structure or null
 - The caller must ensure the seed pointer remains valid for the duration of this call
 */

FFIExtendedPrivKey *derivation_new_master_key(const uint8_t *seed,
                                              size_t seed_len,
                                              FFINetwork network,
                                              FFIError *error)
;

/*
 Derive a BIP44 account path (m/44'/5'/account')
 */

bool derivation_bip44_account_path(FFINetwork network,
                                   unsigned int account_index,
                                   char *path_out,
                                   size_t path_max_len,
                                   FFIError *error)
;

/*
 Derive a BIP44 payment path (m/44'/5'/account'/change/index)
 */

bool derivation_bip44_payment_path(FFINetwork network,
                                   unsigned int account_index,
                                   bool is_change,
                                   unsigned int address_index,
                                   char *path_out,
                                   size_t path_max_len,
                                   FFIError *error)
;

/*
 Derive CoinJoin path (m/9'/5'/4'/account')
 */

bool derivation_coinjoin_path(FFINetwork network,
                              unsigned int account_index,
                              char *path_out,
                              size_t path_max_len,
                              FFIError *error)
;

/*
 Derive identity registration path (m/9'/5'/5'/1'/index')
 */

bool derivation_identity_registration_path(FFINetwork network,
                                           unsigned int identity_index,
                                           char *path_out,
                                           size_t path_max_len,
                                           FFIError *error)
;

/*
 Derive identity top-up path (m/9'/5'/5'/2'/identity_index'/top_up_index')
 */

bool derivation_identity_topup_path(FFINetwork network,
                                    unsigned int identity_index,
                                    unsigned int topup_index,
                                    char *path_out,
                                    size_t path_max_len,
                                    FFIError *error)
;

/*
 Derive identity authentication path (m/9'/5'/5'/0'/identity_index'/key_index')
 */

bool derivation_identity_authentication_path(FFINetwork network,
                                             unsigned int identity_index,
                                             unsigned int key_index,
                                             char *path_out,
                                             size_t path_max_len,
                                             FFIError *error)
;

/*
 Derive private key for a specific path from seed

 # Safety

 - `seed` must be a valid pointer to a byte array of `seed_len` length
 - `path` must be a valid pointer to a null-terminated C string
 - `error` must be a valid pointer to an FFIError structure or null
 - The caller must ensure all pointers remain valid for the duration of this call
 */

FFIExtendedPrivKey *derivation_derive_private_key_from_seed(const uint8_t *seed,
                                                            size_t seed_len,
                                                            const char *path,
                                                            FFINetwork network,
                                                            FFIError *error)
;

/*
 Derive public key from extended private key

 # Safety

 - `xpriv` must be a valid pointer to an FFIExtendedPrivKey
 - `error` must be a valid pointer to an FFIError
 - The returned pointer must be freed with `extended_public_key_free`
 */
 FFIExtendedPubKey *derivation_xpriv_to_xpub(const FFIExtendedPrivKey *xpriv, FFIError *error) ;

/*
 Get extended private key as string

 # Safety

 - `xpriv` must be a valid pointer to an FFIExtendedPrivKey
 - `error` must be a valid pointer to an FFIError
 - The returned string must be freed with `string_free`
 */
 char *derivation_xpriv_to_string(const FFIExtendedPrivKey *xpriv, FFIError *error) ;

/*
 Get extended public key as string

 # Safety

 - `xpub` must be a valid pointer to an FFIExtendedPubKey
 - `error` must be a valid pointer to an FFIError
 - The returned string must be freed with `string_free`
 */
 char *derivation_xpub_to_string(const FFIExtendedPubKey *xpub, FFIError *error) ;

/*
 Get fingerprint from extended public key (4 bytes)

 # Safety

 - `xpub` must be a valid pointer to an FFIExtendedPubKey
 - `fingerprint_out` must be a valid pointer to a buffer of at least 4 bytes
 - `error` must be a valid pointer to an FFIError
 */

bool derivation_xpub_fingerprint(const FFIExtendedPubKey *xpub,
                                 uint8_t *fingerprint_out,
                                 FFIError *error)
;

/*
 Free extended private key

 # Safety

 - `xpriv` must be a valid pointer to an FFIExtendedPrivKey that was allocated by this library
 - The pointer must not be used after calling this function
 - This function must only be called once per allocation
 */
 void derivation_xpriv_free(FFIExtendedPrivKey *xpriv) ;

/*
 Free extended public key

 # Safety

 - `xpub` must be a valid pointer to an FFIExtendedPubKey that was allocated by this library
 - The pointer must not be used after calling this function
 - This function must only be called once per allocation
 */
 void derivation_xpub_free(FFIExtendedPubKey *xpub) ;

/*
 Free derivation path string

 # Safety

 - `s` must be a valid pointer to a C string that was allocated by this library
 - The pointer must not be used after calling this function
 - This function must only be called once per allocation
 */
 void derivation_string_free(char *s) ;

/*
 Derive key using DIP9 path constants for identity

 # Safety

 - `seed` must be a valid pointer to a byte array of `seed_len` length
 - `error` must be a valid pointer to an FFIError structure or null
 - The caller must ensure the seed pointer remains valid for the duration of this call
 */

FFIExtendedPrivKey *dip9_derive_identity_key(const uint8_t *seed,
                                             size_t seed_len,
                                             FFINetwork network,
                                             unsigned int identity_index,
                                             unsigned int key_index,
                                             FFIDerivationPathType key_type,
                                             FFIError *error)
;

/*
 Free an error message

 # Safety

 - `message` must be a valid pointer to a C string that was allocated by this library
 - The pointer must not be used after calling this function
 - This function must only be called once per allocation
 */
 void error_message_free(char *message) ;

/*
 Get extended private key for account

 # Safety

 - `wallet` must be a valid pointer to an FFIWallet
 - `error` must be a valid pointer to an FFIError
 - The returned string must be freed with `string_free`
 */

char *wallet_get_account_xpriv(const FFIWallet *wallet,
                               FFINetwork network,
                               unsigned int account_index,
                               FFIError *error)
;

/*
 Get extended public key for account

 # Safety

 - `wallet` must be a valid pointer to an FFIWallet
 - `error` must be a valid pointer to an FFIError
 - The returned string must be freed with `string_free`
 */

char *wallet_get_account_xpub(const FFIWallet *wallet,
                              FFINetwork network,
                              unsigned int account_index,
                              FFIError *error)
;

/*
 Derive private key at a specific path
 Returns an opaque FFIPrivateKey pointer that must be freed with private_key_free

 # Safety

 - `wallet` must be a valid pointer to an FFIWallet
 - `derivation_path` must be a valid null-terminated C string
 - `error` must be a valid pointer to an FFIError
 - The returned pointer must be freed with `private_key_free`
 */

FFIPrivateKey *wallet_derive_private_key(const FFIWallet *wallet,
                                         FFINetwork network,
                                         const char *derivation_path,
                                         FFIError *error)
;

/*
 Derive extended private key at a specific path
 Returns an opaque FFIExtendedPrivateKey pointer that must be freed with extended_private_key_free

 # Safety

 - `wallet` must be a valid pointer to an FFIWallet
 - `derivation_path` must be a valid null-terminated C string
 - `error` must be a valid pointer to an FFIError
 - The returned pointer must be freed with `extended_private_key_free`
 */

FFIExtendedPrivateKey *wallet_derive_extended_private_key(const FFIWallet *wallet,
                                                          FFINetwork network,
                                                          const char *derivation_path,
                                                          FFIError *error)
;

/*
 Derive private key at a specific path and return as WIF string

 # Safety

 - `wallet` must be a valid pointer to an FFIWallet
 - `derivation_path` must be a valid null-terminated C string
 - `error` must be a valid pointer to an FFIError
 - The returned string must be freed with `string_free`
 */

char *wallet_derive_private_key_as_wif(const FFIWallet *wallet,
                                       FFINetwork network,
                                       const char *derivation_path,
                                       FFIError *error)
;

/*
 Free a private key

 # Safety

 - `key` must be a valid pointer created by private key functions or null
 - After calling this function, the pointer becomes invalid
 */
 void private_key_free(FFIPrivateKey *key) ;

/*
 Free an extended private key

 # Safety

 - `key` must be a valid pointer created by extended private key functions or null
 - After calling this function, the pointer becomes invalid
 */
 void extended_private_key_free(FFIExtendedPrivateKey *key) ;

/*
 Get extended private key as string (xprv format)

 Returns the extended private key in base58 format (xprv... for mainnet, tprv... for testnet)

 # Safety

 - `key` must be a valid pointer to an FFIExtendedPrivateKey
 - `network` is ignored; the network is encoded in the extended key
 - `error` must be a valid pointer to an FFIError
 - The returned string must be freed with `string_free`
 */

char *extended_private_key_to_string(const FFIExtendedPrivateKey *key,
                                     FFINetwork network,
                                     FFIError *error)
;

/*
 Get the private key from an extended private key

 Extracts the non-extended private key from an extended private key.

 # Safety

 - `extended_key` must be a valid pointer to an FFIExtendedPrivateKey
 - `error` must be a valid pointer to an FFIError
 - The returned FFIPrivateKey must be freed with `private_key_free`
 */

FFIPrivateKey *extended_private_key_get_private_key(const FFIExtendedPrivateKey *extended_key,
                                                    FFIError *error)
;

/*
 Get private key as WIF string from FFIPrivateKey

 # Safety

 - `key` must be a valid pointer to an FFIPrivateKey
 - `error` must be a valid pointer to an FFIError
 - The returned string must be freed with `string_free`
 */
 char *private_key_to_wif(const FFIPrivateKey *key, FFINetwork network, FFIError *error) ;

/*
 Derive public key at a specific path
 Returns an opaque FFIPublicKey pointer that must be freed with public_key_free

 # Safety

 - `wallet` must be a valid pointer to an FFIWallet
 - `derivation_path` must be a valid null-terminated C string
 - `error` must be a valid pointer to an FFIError
 - The returned pointer must be freed with `public_key_free`
 */

FFIPublicKey *wallet_derive_public_key(const FFIWallet *wallet,
                                       FFINetwork network,
                                       const char *derivation_path,
                                       FFIError *error)
;

/*
 Derive extended public key at a specific path
 Returns an opaque FFIExtendedPublicKey pointer that must be freed with extended_public_key_free

 # Safety

 - `wallet` must be a valid pointer to an FFIWallet
 - `derivation_path` must be a valid null-terminated C string
 - `error` must be a valid pointer to an FFIError
 - The returned pointer must be freed with `extended_public_key_free`
 */

FFIExtendedPublicKey *wallet_derive_extended_public_key(const FFIWallet *wallet,
                                                        FFINetwork network,
                                                        const char *derivation_path,
                                                        FFIError *error)
;

/*
 Derive public key at a specific path and return as hex string

 # Safety

 - `wallet` must be a valid pointer to an FFIWallet
 - `derivation_path` must be a valid null-terminated C string
 - `error` must be a valid pointer to an FFIError
 - The returned string must be freed with `string_free`
 */

char *wallet_derive_public_key_as_hex(const FFIWallet *wallet,
                                      FFINetwork network,
                                      const char *derivation_path,
                                      FFIError *error)
;

/*
 Free a public key

 # Safety

 - `key` must be a valid pointer created by public key functions or null
 - After calling this function, the pointer becomes invalid
 */
 void public_key_free(FFIPublicKey *key) ;

/*
 Free an extended public key

 # Safety

 - `key` must be a valid pointer created by extended public key functions or null
 - After calling this function, the pointer becomes invalid
 */
 void extended_public_key_free(FFIExtendedPublicKey *key) ;

/*
 Get extended public key as string (xpub format)

 Returns the extended public key in base58 format (xpub... for mainnet, tpub... for testnet)

 # Safety

 - `key` must be a valid pointer to an FFIExtendedPublicKey
 - `network` is ignored; the network is encoded in the extended key
 - `error` must be a valid pointer to an FFIError
 - The returned string must be freed with `string_free`
 */

char *extended_public_key_to_string(const FFIExtendedPublicKey *key,
                                    FFINetwork network,
                                    FFIError *error)
;

/*
 Get the public key from an extended public key

 Extracts the non-extended public key from an extended public key.

 # Safety

 - `extended_key` must be a valid pointer to an FFIExtendedPublicKey
 - `error` must be a valid pointer to an FFIError
 - The returned FFIPublicKey must be freed with `public_key_free`
 */

FFIPublicKey *extended_public_key_get_public_key(const FFIExtendedPublicKey *extended_key,
                                                 FFIError *error)
;

/*
 Get public key as hex string from FFIPublicKey

 # Safety

 - `key` must be a valid pointer to an FFIPublicKey
 - `error` must be a valid pointer to an FFIError
 - The returned string must be freed with `string_free`
 */
 char *public_key_to_hex(const FFIPublicKey *key, FFIError *error) ;

/*
 Convert derivation path string to indices

 # Safety

 - `path` must be a valid null-terminated C string or null
 - `indices_out` must be a valid pointer to store the indices array pointer
 - `hardened_out` must be a valid pointer to store the hardened flags array pointer
 - `count_out` must be a valid pointer to store the count
 - `error` must be a valid pointer to an FFIError
 - The returned arrays must be freed with `derivation_path_free`
 */

bool derivation_path_parse(const char *path,
                           uint32_t **indices_out,
                           bool **hardened_out,
                           size_t *count_out,
                           FFIError *error)
;

/*
 Free derivation path arrays
 Note: This function expects the count to properly free the slices

 # Safety

 - `indices` must be a valid pointer created by `derivation_path_parse` or null
 - `hardened` must be a valid pointer created by `derivation_path_parse` or null
 - `count` must match the count from `derivation_path_parse`
 - After calling this function, the pointers become invalid
 */
 void derivation_path_free(uint32_t *indices, bool *hardened, size_t count) ;

/*
 Get the next unused receive address

 Generates the next unused receive address for the specified account.
 This properly manages address gaps and updates the managed wallet state.

 # Safety

 - `managed_wallet` must be a valid pointer to an FFIManagedWalletInfo
 - `wallet` must be a valid pointer to an FFIWallet
 - `error` must be a valid pointer to an FFIError
 - The returned string must be freed by the caller
 */

char *managed_wallet_get_next_bip44_receive_address(FFIManagedWalletInfo *managed_wallet,
                                                    const FFIWallet *wallet,
                                                    FFINetwork network,
                                                    unsigned int account_index,
                                                    FFIError *error)
;

/*
 Get the next unused change address

 Generates the next unused change address for the specified account.
 This properly manages address gaps and updates the managed wallet state.

 # Safety

 - `managed_wallet` must be a valid pointer to an FFIManagedWalletInfo
 - `wallet` must be a valid pointer to an FFIWallet
 - `error` must be a valid pointer to an FFIError
 - The returned string must be freed by the caller
 */

char *managed_wallet_get_next_bip44_change_address(FFIManagedWalletInfo *managed_wallet,
                                                   const FFIWallet *wallet,
                                                   FFINetwork network,
                                                   unsigned int account_index,
                                                   FFIError *error)
;

/*
 Get BIP44 external (receive) addresses in the specified range

 Returns external addresses from start_index (inclusive) to end_index (exclusive).
 If addresses in the range haven't been generated yet, they will be generated.

 # Safety

 - `managed_wallet` must be a valid pointer to an FFIManagedWalletInfo
 - `wallet` must be a valid pointer to an FFIWallet
 - `addresses_out` must be a valid pointer to store the address array pointer
 - `count_out` must be a valid pointer to store the count
 - `error` must be a valid pointer to an FFIError
 - Free the result with address_array_free(addresses_out, count_out)
 */

bool managed_wallet_get_bip_44_external_address_range(FFIManagedWalletInfo *managed_wallet,
                                                      const FFIWallet *wallet,
                                                      FFINetwork network,
                                                      unsigned int account_index,
                                                      unsigned int start_index,
                                                      unsigned int end_index,
                                                      char ***addresses_out,
                                                      size_t *count_out,
                                                      FFIError *error)
;

/*
 Get BIP44 internal (change) addresses in the specified range

 Returns internal addresses from start_index (inclusive) to end_index (exclusive).
 If addresses in the range haven't been generated yet, they will be generated.

 # Safety

 - `managed_wallet` must be a valid pointer to an FFIManagedWalletInfo
 - `wallet` must be a valid pointer to an FFIWallet
 - `addresses_out` must be a valid pointer to store the address array pointer
 - `count_out` must be a valid pointer to store the count
 - `error` must be a valid pointer to an FFIError
 - Free the result with address_array_free(addresses_out, count_out)
 */

bool managed_wallet_get_bip_44_internal_address_range(FFIManagedWalletInfo *managed_wallet,
                                                      const FFIWallet *wallet,
                                                      FFINetwork network,
                                                      unsigned int account_index,
                                                      unsigned int start_index,
                                                      unsigned int end_index,
                                                      char ***addresses_out,
                                                      size_t *count_out,
                                                      FFIError *error)
;

/*
 Get wallet balance from managed wallet info

 Returns the balance breakdown including confirmed, unconfirmed, locked, and total amounts.

 # Safety

 - `managed_wallet` must be a valid pointer to an FFIManagedWalletInfo
 - `confirmed_out` must be a valid pointer to store the confirmed balance
 - `unconfirmed_out` must be a valid pointer to store the unconfirmed balance
 - `locked_out` must be a valid pointer to store the locked balance
 - `total_out` must be a valid pointer to store the total balance
 - `error` must be a valid pointer to an FFIError
 */

bool managed_wallet_get_balance(const FFIManagedWalletInfo *managed_wallet,
                                uint64_t *confirmed_out,
                                uint64_t *unconfirmed_out,
                                uint64_t *locked_out,
                                uint64_t *total_out,
                                FFIError *error)
;

/*
 Free managed wallet info

 # Safety

 - `managed_wallet` must be a valid pointer to an FFIManagedWalletInfo or null
 - After calling this function, the pointer becomes invalid and must not be used
 */
 void managed_wallet_free(FFIManagedWalletInfo *managed_wallet) ;

/*
 Free managed wallet info returned by wallet_manager_get_managed_wallet_info

 # Safety

 - `wallet_info` must be a valid pointer returned by wallet_manager_get_managed_wallet_info or null
 - After calling this function, the pointer becomes invalid and must not be used
 */
 void managed_wallet_info_free(FFIManagedWalletInfo *wallet_info) ;

/*
 Generate a new mnemonic with specified word count (12, 15, 18, 21, or 24)
 */
 char *mnemonic_generate(unsigned int word_count, FFIError *error) ;

/*
 Generate a new mnemonic with specified language and word count
 */

char *mnemonic_generate_with_language(unsigned int word_count,
                                      FFILanguage language,
                                      FFIError *error)
;

/*
 Validate a mnemonic phrase

 # Safety

 - `mnemonic` must be a valid null-terminated C string or null
 - `error` must be a valid pointer to an FFIError
 */
 bool mnemonic_validate(const char *mnemonic, FFIError *error) ;

/*
 Convert mnemonic to seed with optional passphrase

 # Safety

 - `mnemonic` must be a valid null-terminated C string
 - `passphrase` must be a valid null-terminated C string or null
 - `seed_out` must be a valid pointer to a buffer of at least 64 bytes
 - `seed_len` must be a valid pointer to store the seed length
 - `error` must be a valid pointer to an FFIError
 */

bool mnemonic_to_seed(const char *mnemonic,
                      const char *passphrase,
                      uint8_t *seed_out,
                      size_t *seed_len,
                      FFIError *error)
;

/*
 Get word count from mnemonic

 # Safety

 - `mnemonic` must be a valid null-terminated C string or null
 - `error` must be a valid pointer to an FFIError
 */
 unsigned int mnemonic_word_count(const char *mnemonic, FFIError *error) ;

/*
 Free a mnemonic string

 # Safety

 - `mnemonic` must be a valid pointer created by mnemonic generation functions or null
 - After calling this function, the pointer becomes invalid
 */
 void mnemonic_free(char *mnemonic) ;

/*
 Build a transaction

 # Safety

 - `wallet` must be a valid pointer to an FFIWallet
 - `outputs` must be a valid pointer to an array of FFITxOutput with at least `outputs_count` elements
 - `tx_bytes_out` must be a valid pointer to store the transaction bytes pointer
 - `tx_len_out` must be a valid pointer to store the transaction length
 - `error` must be a valid pointer to an FFIError
 - The returned transaction bytes must be freed with `transaction_bytes_free`
 */

bool wallet_build_transaction(FFIWallet *wallet,
                              FFINetwork network,
                              unsigned int account_index,
                              const FFITxOutput *outputs,
                              size_t outputs_count,
                              uint64_t fee_per_kb,
                              uint8_t **tx_bytes_out,
                              size_t *tx_len_out,
                              FFIError *error)
;

/*
 Sign a transaction

 # Safety

 - `wallet` must be a valid pointer to an FFIWallet
 - `tx_bytes` must be a valid pointer to transaction bytes with at least `tx_len` bytes
 - `signed_tx_out` must be a valid pointer to store the signed transaction bytes pointer
 - `signed_len_out` must be a valid pointer to store the signed transaction length
 - `error` must be a valid pointer to an FFIError
 - The returned signed transaction bytes must be freed with `transaction_bytes_free`
 */

bool wallet_sign_transaction(const FFIWallet *wallet,
                             FFINetwork network,
                             const uint8_t *tx_bytes,
                             size_t tx_len,
                             uint8_t **signed_tx_out,
                             size_t *signed_len_out,
                             FFIError *error)
;

/*
 Check if a transaction belongs to the wallet using ManagedWalletInfo

 # Safety

 - `wallet` must be a valid mutable pointer to an FFIWallet
 - `tx_bytes` must be a valid pointer to transaction bytes with at least `tx_len` bytes
 - `inputs_spent_out` must be a valid pointer to store the spent inputs count
 - `addresses_used_out` must be a valid pointer to store the used addresses count
 - `new_balance_out` must be a valid pointer to store the new balance
 - `new_address_out` must be a valid pointer to store the address array pointer
 - `new_address_count_out` must be a valid pointer to store the address count
 - `error` must be a valid pointer to an FFIError
 */

bool wallet_check_transaction(FFIWallet *wallet,
                              FFINetwork network,
                              const uint8_t *tx_bytes,
                              size_t tx_len,
                              FFITransactionContext context_type,
                              uint32_t block_height,
                              const uint8_t *block_hash,
                              uint64_t timestamp,
                              bool update_state,
                              FFITransactionCheckResult *result_out,
                              FFIError *error)
;

/*
 Free transaction bytes

 # Safety

 - `tx_bytes` must be a valid pointer created by transaction functions or null
 - After calling this function, the pointer becomes invalid
 */
 void transaction_bytes_free(uint8_t *tx_bytes) ;

/*
 Free a string

 # Safety

 - `s` must be a valid pointer created by C string creation functions or null
 - After calling this function, the pointer becomes invalid
 */
 void string_free(char *s) ;

/*
 Get all UTXOs from managed wallet info

 # Safety

 - `managed_info` must be a valid pointer to an FFIManagedWalletInfo instance
 - `utxos_out` must be a valid pointer to store the UTXO array pointer
 - `count_out` must be a valid pointer to store the UTXO count
 - `error` must be a valid pointer to an FFIError structure or null
 - The caller must ensure all pointers remain valid for the duration of this call
 - The returned UTXO array must be freed with `utxo_array_free` when no longer needed
 */

bool managed_wallet_get_utxos(const FFIManagedWalletInfo *managed_info,
                              FFINetwork network,
                              FFIUTXO **utxos_out,
                              size_t *count_out,
                              FFIError *error)
;

/*
 Get all UTXOs (deprecated - use managed_wallet_get_utxos instead)

 # Safety

 This function is deprecated and returns an empty list.
 Use `managed_wallet_get_utxos` with a ManagedWalletInfo instead.
 */

bool wallet_get_utxos(const FFIWallet *_wallet,
                      FFINetwork _network,
                      FFIUTXO **utxos_out,
                      size_t *count_out,
                      FFIError *error)
;

/*
 Free UTXO array

 # Safety

 - `utxos` must be a valid pointer to an array of FFIUTXO structs allocated by this library
 - `count` must match the number of UTXOs in the array
 - The pointer must not be used after calling this function
 - This function must only be called once per array
 */
 void utxo_array_free(FFIUTXO *utxos, size_t count) ;

/*
 Create a new wallet from mnemonic with options

 # Safety

 - `mnemonic` must be a valid pointer to a null-terminated C string
 - `passphrase` must be a valid pointer to a null-terminated C string or null
 - `account_options` must be a valid pointer to FFIWalletAccountCreationOptions or null
 - `error` must be a valid pointer to an FFIError structure or null
 - The caller must ensure all pointers remain valid for the duration of this call
 - The returned pointer must be freed with `wallet_free` when no longer needed
 */

FFIWallet *wallet_create_from_mnemonic_with_options(const char *mnemonic,
                                                    const char *passphrase,
                                                    FFINetwork network,
                                                    const FFIWalletAccountCreationOptions *account_options,
                                                    FFIError *error)
;

/*
 Create a new wallet from mnemonic (backward compatibility)

 # Safety

 - `mnemonic` must be a valid pointer to a null-terminated C string
 - `passphrase` must be a valid pointer to a null-terminated C string or null
 - `error` must be a valid pointer to an FFIError structure or null
 - The caller must ensure all pointers remain valid for the duration of this call
 - The returned pointer must be freed with `wallet_free` when no longer needed
 */

FFIWallet *wallet_create_from_mnemonic(const char *mnemonic,
                                       const char *passphrase,
                                       FFINetwork network,
                                       FFIError *error)
;

/*
 Create a new wallet from seed with options

 # Safety

 - `seed` must be a valid pointer to a byte array of `seed_len` length
 - `account_options` must be a valid pointer to FFIWalletAccountCreationOptions or null
 - `error` must be a valid pointer to an FFIError structure or null
 - The caller must ensure all pointers remain valid for the duration of this call
 */

FFIWallet *wallet_create_from_seed_with_options(const uint8_t *seed,
                                                size_t seed_len,
                                                FFINetwork network,
                                                const FFIWalletAccountCreationOptions *account_options,
                                                FFIError *error)
;

/*
 Create a new wallet from seed (backward compatibility)

 # Safety

 - `seed` must be a valid pointer to a byte array of `seed_len` length
 - `error` must be a valid pointer to an FFIError structure or null
 - The caller must ensure all pointers remain valid for the duration of this call
 */

FFIWallet *wallet_create_from_seed(const uint8_t *seed,
                                   size_t seed_len,
                                   FFINetwork network,
                                   FFIError *error)
;

/*
 Create a new wallet from seed bytes

 # Safety

 - `seed_bytes` must be a valid pointer to a byte array of `seed_len` length
 - `error` must be a valid pointer to an FFIError structure or null
 - The caller must ensure all pointers remain valid for the duration of this call
 - The returned pointer must be freed with `wallet_free` when no longer needed
 */

FFIWallet *wallet_create_from_seed_bytes(const uint8_t *seed_bytes,
                                         size_t seed_len,
                                         FFINetwork network,
                                         FFIError *error)
;

/*
 Create a watch-only wallet from extended public key

 # Safety

 - `xpub` must be a valid pointer to a null-terminated C string
 - `error` must be a valid pointer to an FFIError structure or null
 - The caller must ensure all pointers remain valid for the duration of this call
 */
 FFIWallet *wallet_create_from_xpub(const char *xpub, FFINetwork network, FFIError *error) ;

/*
 Create a new random wallet with options

 # Safety

 - `account_options` must be a valid pointer to FFIWalletAccountCreationOptions or null
 - `error` must be a valid pointer to an FFIError structure or null
 - The caller must ensure all pointers remain valid for the duration of this call
 */

FFIWallet *wallet_create_random_with_options(FFINetwork network,
                                             const FFIWalletAccountCreationOptions *account_options,
                                             FFIError *error)
;

/*
 Create a new random wallet (backward compatibility)

 # Safety

 - `error` must be a valid pointer to an FFIError structure or null
 - The caller must ensure the pointer remains valid for the duration of this call
 */
 FFIWallet *wallet_create_random(FFINetwork network, FFIError *error) ;

/*
 Get wallet ID (32-byte hash)

 # Safety

 - `wallet` must be a valid pointer to an FFIWallet
 - `id_out` must be a valid pointer to a 32-byte buffer
 - `error` must be a valid pointer to an FFIError structure or null
 - The caller must ensure all pointers remain valid for the duration of this call
 */
 bool wallet_get_id(const FFIWallet *wallet, uint8_t *id_out, FFIError *error) ;

/*
 Check if wallet has mnemonic

 # Safety

 - `wallet` must be a valid pointer to an FFIWallet instance
 - `error` must be a valid pointer to an FFIError structure or null
 - The caller must ensure all pointers remain valid for the duration of this call
 */
 bool wallet_has_mnemonic(const FFIWallet *wallet, FFIError *error) ;

/*
 Check if wallet is watch-only

 # Safety

 - `wallet` must be a valid pointer to an FFIWallet instance
 - `error` must be a valid pointer to an FFIError structure or null
 - The caller must ensure all pointers remain valid for the duration of this call
 */
 bool wallet_is_watch_only(const FFIWallet *wallet, FFIError *error) ;

/*
 Get extended public key for account

 # Safety

 - `wallet` must be a valid pointer to an FFIWallet instance
 - `error` must be a valid pointer to an FFIError structure or null
 - The caller must ensure all pointers remain valid for the duration of this call
 - The returned C string must be freed by the caller when no longer needed
 */

char *wallet_get_xpub(const FFIWallet *wallet,
                      FFINetwork network,
                      unsigned int account_index,
                      FFIError *error)
;

/*
 Free a wallet

 # Safety

 - `wallet` must be a valid pointer to an FFIWallet that was created by this library
 - The pointer must not be used after calling this function
 - This function must only be called once per wallet
 */
 void wallet_free(FFIWallet *wallet) ;

/*
 Free a const wallet handle

 This is a const-safe wrapper for wallet_free() that accepts a const pointer.
 Use this function when you have a *const FFIWallet that needs to be freed,
 such as wallets returned from wallet_manager_get_wallet().

 # Safety

 - `wallet` must be a valid pointer created by wallet creation functions or null
 - After calling this function, the pointer becomes invalid
 - This function must only be called once per wallet
 - The wallet must have been allocated by this library (not stack or static memory)
 */
 void wallet_free_const(const FFIWallet *wallet) ;

/*
 Add an account to the wallet without xpub

 # Safety

 This function dereferences a raw pointer to FFIWallet.
 The caller must ensure that:
 - The wallet pointer is either null or points to a valid FFIWallet
 - The FFIWallet remains valid for the duration of this call
 */

FFIAccountResult wallet_add_account(FFIWallet *wallet,
                                    FFINetwork network,
                                    unsigned int account_type,
                                    unsigned int account_index)
;

/*
 Add an account to the wallet with xpub as byte array

 # Safety

 This function dereferences raw pointers.
 The caller must ensure that:
 - The wallet pointer is either null or points to a valid FFIWallet
 - The xpub_bytes pointer is either null or points to at least xpub_len bytes
 - The FFIWallet remains valid for the duration of this call
 */

FFIAccountResult wallet_add_account_with_xpub_bytes(FFIWallet *wallet,
                                                    FFINetwork network,
                                                    unsigned int account_type,
                                                    unsigned int account_index,
                                                    const uint8_t *xpub_bytes,
                                                    size_t xpub_len)
;

/*
 Add an account to the wallet with xpub as string

 # Safety

 This function dereferences raw pointers.
 The caller must ensure that:
 - The wallet pointer is either null or points to a valid FFIWallet
 - The xpub_string pointer is either null or points to a valid null-terminated C string
 - The FFIWallet remains valid for the duration of this call
 */

FFIAccountResult wallet_add_account_with_string_xpub(FFIWallet *wallet,
                                                     FFINetwork network,
                                                     unsigned int account_type,
                                                     unsigned int account_index,
                                                     const char *xpub_string)
;

/*
 Create a new wallet manager
 */
 FFIWalletManager *wallet_manager_create(FFIError *error) ;

/*
 Add a wallet from mnemonic to the manager with options

 # Safety

 - `manager` must be a valid pointer to an FFIWalletManager instance
 - `mnemonic` must be a valid pointer to a null-terminated C string
 - `passphrase` must be a valid pointer to a null-terminated C string or null
 - `account_options` must be a valid pointer to FFIWalletAccountCreationOptions or null
 - `error` must be a valid pointer to an FFIError structure or null
 - The caller must ensure all pointers remain valid for the duration of this call
 */

bool wallet_manager_add_wallet_from_mnemonic_with_options(FFIWalletManager *manager,
                                                          const char *mnemonic,
                                                          const char *passphrase,
                                                          FFINetwork network,
                                                          const FFIWalletAccountCreationOptions *account_options,
                                                          FFIError *error)
;

/*
 Add a wallet from mnemonic to the manager (backward compatibility)

 # Safety

 - `manager` must be a valid pointer to an FFIWalletManager instance
 - `mnemonic` must be a valid pointer to a null-terminated C string
 - `passphrase` must be a valid pointer to a null-terminated C string or null
 - `error` must be a valid pointer to an FFIError structure or null
 - The caller must ensure all pointers remain valid for the duration of this call
 */

bool wallet_manager_add_wallet_from_mnemonic(FFIWalletManager *manager,
                                             const char *mnemonic,
                                             const char *passphrase,
                                             FFINetwork network,
                                             FFIError *error)
;

/*
 Get wallet IDs

 # Safety

 - `manager` must be a valid pointer to an FFIWalletManager
 - `wallet_ids_out` must be a valid pointer to a pointer that will receive the wallet IDs
 - `count_out` must be a valid pointer to receive the count
 - `error` must be a valid pointer to an FFIError structure or null
 - The caller must ensure all pointers remain valid for the duration of this call
 */

bool wallet_manager_get_wallet_ids(const FFIWalletManager *manager,
                                   uint8_t **wallet_ids_out,
                                   size_t *count_out,
                                   FFIError *error)
;

/*
 Get a wallet from the manager

 Returns a reference to the wallet if found

 # Safety

 - `manager` must be a valid pointer to an FFIWalletManager instance
 - `wallet_id` must be a valid pointer to a 32-byte wallet ID
 - `error` must be a valid pointer to an FFIError structure or null
 - The caller must ensure all pointers remain valid for the duration of this call
 - The returned wallet must be freed with wallet_free_const()
 */

const FFIWallet *wallet_manager_get_wallet(const FFIWalletManager *manager,
                                           const uint8_t *wallet_id,
                                           FFIError *error)
;

/*
 Get managed wallet info from the manager

 Returns a reference to the managed wallet info if found

 # Safety

 - `manager` must be a valid pointer to an FFIWalletManager instance
 - `wallet_id` must be a valid pointer to a 32-byte wallet ID
 - `error` must be a valid pointer to an FFIError structure or null
 - The caller must ensure all pointers remain valid for the duration of this call
 - The returned managed wallet info must be freed with managed_wallet_info_free()
 */

FFIManagedWalletInfo *wallet_manager_get_managed_wallet_info(const FFIWalletManager *manager,
                                                             const uint8_t *wallet_id,
                                                             FFIError *error)
;

/*
 Get next receive address for a wallet

 # Safety

 - `manager` must be a valid pointer to an FFIWalletManager
 - `wallet_id` must be a valid pointer to a 32-byte wallet ID
 - `error` must be a valid pointer to an FFIError structure or null
 - The caller must ensure all pointers remain valid for the duration of this call
 */

char *wallet_manager_get_receive_address(FFIWalletManager *manager,
                                         const uint8_t *wallet_id,
                                         FFINetwork network,
                                         unsigned int account_index,
                                         FFIError *error)
;

/*
 Get next change address for a wallet

 # Safety

 - `manager` must be a valid pointer to an FFIWalletManager
 - `wallet_id` must be a valid pointer to a 32-byte wallet ID
 - `error` must be a valid pointer to an FFIError structure or null
 - The caller must ensure all pointers remain valid for the duration of this call
 */

char *wallet_manager_get_change_address(FFIWalletManager *manager,
                                        const uint8_t *wallet_id,
                                        FFINetwork network,
                                        unsigned int account_index,
                                        FFIError *error)
;

/*
 Get wallet balance

 Returns the confirmed and unconfirmed balance for a specific wallet

 # Safety

 - `manager` must be a valid pointer to an FFIWalletManager instance
 - `wallet_id` must be a valid pointer to a 32-byte wallet ID
 - `confirmed_out` must be a valid pointer to a u64 (maps to C uint64_t)
 - `unconfirmed_out` must be a valid pointer to a u64 (maps to C uint64_t)
 - `error` must be a valid pointer to an FFIError structure or null
 - The caller must ensure all pointers remain valid for the duration of this call
 */

bool wallet_manager_get_wallet_balance(const FFIWalletManager *manager,
                                       const uint8_t *wallet_id,
                                       uint64_t *confirmed_out,
                                       uint64_t *unconfirmed_out,
                                       FFIError *error)
;

/*
 Process a transaction through all wallets

 Checks a transaction against all wallets and updates their states if relevant.
 Returns true if the transaction was relevant to at least one wallet.

 # Safety

 - `manager` must be a valid pointer to an FFIWalletManager instance
 - `tx_bytes` must be a valid pointer to transaction bytes
 - `tx_len` must be the length of the transaction bytes
 - `network` is the network type
 - `context` must be a valid pointer to FFITransactionContextDetails
 - `update_state_if_found` indicates whether to update wallet state when transaction is relevant
 - `error` must be a valid pointer to an FFIError structure or null
 - The caller must ensure all pointers remain valid for the duration of this call
 */

bool wallet_manager_process_transaction(FFIWalletManager *manager,
                                        const uint8_t *tx_bytes,
                                        size_t tx_len,
                                        FFINetwork network,
                                        const FFITransactionContextDetails *context,
                                        bool update_state_if_found,
                                        FFIError *error)
;

/*
 Get monitored addresses for a network

 # Safety

 - `manager` must be a valid pointer to an FFIWalletManager
 - `addresses_out` must be a valid pointer to a pointer that will receive the addresses array
 - `count_out` must be a valid pointer to receive the count
 - `error` must be a valid pointer to an FFIError structure or null
 - The caller must ensure all pointers remain valid for the duration of this call
 */

bool wallet_manager_get_monitored_addresses(const FFIWalletManager *manager,
                                            FFINetwork network,
                                            char ***addresses_out,
                                            size_t *count_out,
                                            FFIError *error)
;

/*
 Update block height for a network

 # Safety

 - `manager` must be a valid pointer to an FFIWalletManager
 - `error` must be a valid pointer to an FFIError structure or null
 - The caller must ensure all pointers remain valid for the duration of this call
 */

bool wallet_manager_update_height(FFIWalletManager *manager,
                                  FFINetwork network,
                                  unsigned int height,
                                  FFIError *error)
;

/*
 Get current height for a network

 # Safety

 - `manager` must be a valid pointer to an FFIWalletManager
 - `error` must be a valid pointer to an FFIError structure or null
 - The caller must ensure all pointers remain valid for the duration of this call
 */

unsigned int wallet_manager_current_height(const FFIWalletManager *manager,
                                           FFINetwork network,
                                           FFIError *error)
;

/*
 Get wallet count

 # Safety

 - `manager` must be a valid pointer to an FFIWalletManager instance
 - `error` must be a valid pointer to an FFIError structure or null
 - The caller must ensure all pointers remain valid for the duration of this call
 */
 size_t wallet_manager_wallet_count(const FFIWalletManager *manager, FFIError *error) ;

/*
 Free wallet manager

 # Safety

 - `manager` must be a valid pointer to an FFIWalletManager that was created by this library
 - The pointer must not be used after calling this function
 - This function must only be called once per manager
 */
 void wallet_manager_free(FFIWalletManager *manager) ;

/*
 Free wallet IDs buffer

 # Safety

 - `wallet_ids` must be a valid pointer to a buffer allocated by this library
 - `count` must match the number of wallet IDs in the buffer
 - The pointer must not be used after calling this function
 - This function must only be called once per buffer
 */
 void wallet_manager_free_wallet_ids(uint8_t *wallet_ids, size_t count) ;

/*
 Free address array

 # Safety

 - `addresses` must be a valid pointer to an array of C string pointers allocated by this library
 - `count` must match the original allocation size
 - Each address pointer in the array must be either null or a valid C string allocated by this library
 - The pointers must not be used after calling this function
 - This function must only be called once per allocation
 */

void wallet_manager_free_addresses(char **addresses,
                                   size_t count)
;

/*
 Encrypt a private key with BIP38
 */

char *bip38_encrypt_private_key(const char *private_key,
                                const char *passphrase,
                                FFINetwork network,
                                FFIError *error)
;

/*
 Decrypt a BIP38 encrypted private key
 */

char *bip38_decrypt_private_key(const char *encrypted_key,
                                const char *passphrase,
                                FFIError *error)
;

#ifdef __cplusplus
}  // extern "C"
#endif  // __cplusplus

#endif  /* KEY_WALLET_FFI_H */
