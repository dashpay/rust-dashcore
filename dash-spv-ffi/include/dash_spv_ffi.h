/* dash-spv-ffi C bindings - Auto-generated by cbindgen */

#ifndef DASH_SPV_FFI_H
#define DASH_SPV_FFI_H

/* Generated with cbindgen:0.29.2 */

/* Warning: This file is auto-generated by cbindgen. Do not modify manually. */

#include <stdarg.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>

#ifdef __cplusplus
namespace dash_spv_ffi {
#endif  // __cplusplus

typedef enum FFISyncStage {
  Connecting = 0,
  QueryingHeight = 1,
  Downloading = 2,
  Validating = 3,
  Storing = 4,
  DownloadingFilterHeaders = 5,
  DownloadingFilters = 6,
  DownloadingBlocks = 7,
  Complete = 8,
  Failed = 9,
} FFISyncStage;

typedef enum FFIMempoolStrategy {
  FetchAll = 0,
  BloomFilter = 1,
} FFIMempoolStrategy;

typedef struct FFIDashSpvClient FFIDashSpvClient;

typedef struct FFIClientConfig {
  void *inner;
  uint32_t worker_threads;

} FFIClientConfig;

typedef struct FFIString {
  char *ptr;
  uintptr_t length;
} FFIString;

typedef struct FFISyncProgress {
  uint32_t header_height;
  uint32_t filter_header_height;
  uint32_t masternode_height;
  uint32_t peer_count;
  bool filter_sync_available;
  uint32_t filters_downloaded;
  uint32_t last_synced_filter_height;
} FFISyncProgress;

typedef struct FFIDetailedSyncProgress {
  uint32_t total_height;
  double percentage;
  double headers_per_second;
  int64_t estimated_seconds_remaining;
  enum FFISyncStage stage;
  struct FFIString stage_message;
  struct FFISyncProgress overview;
  uint64_t total_headers;
  int64_t sync_start_timestamp;
} FFIDetailedSyncProgress;

typedef void (*BlockCallback)(uint32_t height, const uint8_t (*hash)[32], void *user_data);

typedef void (*TransactionCallback)(const uint8_t (*txid)[32],
                                    bool confirmed,
                                    int64_t amount,
                                    const char *addresses,
                                    uint32_t block_height,
                                    void *user_data);

typedef void (*BalanceCallback)(uint64_t confirmed, uint64_t unconfirmed, void *user_data);

typedef void (*MempoolTransactionCallback)(const uint8_t (*txid)[32],
                                           int64_t amount,
                                           const char *addresses,
                                           bool is_instant_send,
                                           void *user_data);

typedef void (*MempoolConfirmedCallback)(const uint8_t (*txid)[32],
                                         uint32_t block_height,
                                         const uint8_t (*block_hash)[32],
                                         void *user_data);

typedef void (*MempoolRemovedCallback)(const uint8_t (*txid)[32], uint8_t reason, void *user_data);

typedef void (*CompactFilterMatchedCallback)(const uint8_t (*block_hash)[32],
                                             const char *matched_scripts,
                                             const char *wallet_id,
                                             void *user_data);

typedef void (*WalletTransactionCallback)(const char *wallet_id,
                                          uint32_t account_index,
                                          const uint8_t (*txid)[32],
                                          bool confirmed,
                                          int64_t amount,
                                          const char *addresses,
                                          uint32_t block_height,
                                          bool is_ours,
                                          void *user_data);

typedef struct FFIEventCallbacks {
  BlockCallback on_block;
  TransactionCallback on_transaction;
  BalanceCallback on_balance_update;
  MempoolTransactionCallback on_mempool_transaction_added;
  MempoolConfirmedCallback on_mempool_transaction_confirmed;
  MempoolRemovedCallback on_mempool_transaction_removed;
  CompactFilterMatchedCallback on_compact_filter_matched;
  WalletTransactionCallback on_wallet_transaction;
  void *user_data;
} FFIEventCallbacks;

/**
 * Opaque handle to the wallet manager owned by the SPV client.
 *
 * This is intentionally zero-sized so it can be used purely as an FFI handle
 * while still allowing Rust to cast to the underlying key-wallet manager
 * implementation when necessary.
 */
typedef struct FFIWalletManager {
  uint8_t _private[0];
} FFIWalletManager;

/**
 * FFIResult type for error handling
 */
typedef struct FFIResult {
  int32_t error_code;
  const char *error_message;
} FFIResult;

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

/**
 * Get the latest checkpoint for the given network.
 *
 * # Safety
 * - `out_height` must be a valid pointer to a `u32`.
 * - `out_hash` must point to at least 32 writable bytes.
 */

int32_t dash_spv_ffi_checkpoint_latest(FFINetwork network,
                                       uint32_t *out_height,
                                       uint8_t *out_hash)
;

/**
 * Get the last checkpoint at or before a given height.
 *
 * # Safety
 * - `out_height` must be a valid pointer to a `u32`.
 * - `out_hash` must point to at least 32 writable bytes.
 */

int32_t dash_spv_ffi_checkpoint_before_height(FFINetwork network,
                                              uint32_t height,
                                              uint32_t *out_height,
                                              uint8_t *out_hash)
;

/**
 * Get the last checkpoint at or before a given UNIX timestamp (seconds).
 *
 * # Safety
 * - `out_height` must be a valid pointer to a `u32`.
 * - `out_hash` must point to at least 32 writable bytes.
 */

int32_t dash_spv_ffi_checkpoint_before_timestamp(FFINetwork network,
                                                 uint32_t timestamp,
                                                 uint32_t *out_height,
                                                 uint8_t *out_hash)
;

/**
 * Create a new SPV client and return an opaque pointer.
 *
 * # Safety
 * - `config` must be a valid, non-null pointer for the duration of the call.
 * - The returned pointer must be freed with `dash_spv_ffi_client_destroy`.
 */
 struct FFIDashSpvClient *dash_spv_ffi_client_new(const struct FFIClientConfig *config) ;

/**
 * Drain pending events and invoke configured callbacks (non-blocking).
 *
 * # Safety
 * - `client` must be a valid, non-null pointer.
 */
 int32_t dash_spv_ffi_client_drain_events(struct FFIDashSpvClient *client) ;

/**
 * Update the running client's configuration.
 *
 * # Safety
 * - `client` must be a valid pointer to an `FFIDashSpvClient`.
 * - `config` must be a valid pointer to an `FFIClientConfig`.
 * - The network in `config` must match the client's network; changing networks at runtime is not supported.
 */

int32_t dash_spv_ffi_client_update_config(struct FFIDashSpvClient *client,
                                          const struct FFIClientConfig *config)
;

/**
 * Start the SPV client.
 *
 * # Safety
 * - `client` must be a valid, non-null pointer to a created client.
 */
 int32_t dash_spv_ffi_client_start(struct FFIDashSpvClient *client) ;

/**
 * Stop the SPV client.
 *
 * # Safety
 * - `client` must be a valid, non-null pointer to a created client.
 */
 int32_t dash_spv_ffi_client_stop(struct FFIDashSpvClient *client) ;

/**
 * Sync the SPV client to the chain tip with detailed progress updates.
 *
 * # Safety
 *
 * This function is unsafe because:
 * - `client` must be a valid pointer to an initialized `FFIDashSpvClient`
 * - `user_data` must satisfy thread safety requirements:
 *   - If non-null, it must point to data that is safe to access from multiple threads
 *   - The caller must ensure proper synchronization if the data is mutable
 *   - The data must remain valid for the entire duration of the sync operation
 * - Both `progress_callback` and `completion_callback` must be thread-safe and can be called from any thread
 *
 * # Parameters
 *
 * - `client`: Pointer to the SPV client
 * - `progress_callback`: Optional callback invoked periodically with sync progress
 * - `completion_callback`: Optional callback invoked on completion
 * - `user_data`: Optional user data pointer passed to all callbacks
 *
 * # Returns
 *
 * 0 on success, error code on failure
 */

int32_t dash_spv_ffi_client_sync_to_tip_with_progress(struct FFIDashSpvClient *client,
                                                      void (*progress_callback)(const struct FFIDetailedSyncProgress*,
                                                                                void*),
                                                      void (*completion_callback)(bool,
                                                                                  const char*,
                                                                                  void*),
                                                      void *user_data)
;

/**
 * Cancels the sync operation.
 *
 * This stops the SPV client, clears callbacks, and joins active threads so the sync
 * operation halts immediately.
 *
 * # Safety
 * The client pointer must be valid and non-null.
 *
 * # Returns
 * Returns 0 on success, or an error code on failure.
 */
 int32_t dash_spv_ffi_client_cancel_sync(struct FFIDashSpvClient *client) ;

/**
 * Get the current sync progress snapshot.
 *
 * # Safety
 * - `client` must be a valid, non-null pointer.
 */
 struct FFISyncProgress *dash_spv_ffi_client_get_sync_progress(struct FFIDashSpvClient *client) ;

/**
 * Get the current chain tip hash (32 bytes) if available.
 *
 * # Safety
 * - `client` must be a valid, non-null pointer.
 * - `out_hash` must be a valid pointer to a 32-byte buffer.
 */
 int32_t dash_spv_ffi_client_get_tip_hash(struct FFIDashSpvClient *client, uint8_t *out_hash) ;

/**
 * Get the current chain tip height (absolute).
 *
 * # Safety
 * - `client` must be a valid, non-null pointer.
 * - `out_height` must be a valid, non-null pointer.
 */
 int32_t dash_spv_ffi_client_get_tip_height(struct FFIDashSpvClient *client, uint32_t *out_height) ;

/**
 * Clear all persisted SPV storage (headers, filters, metadata, sync state).
 *
 * # Safety
 * - `client` must be a valid, non-null pointer.
 */
 int32_t dash_spv_ffi_client_clear_storage(struct FFIDashSpvClient *client) ;

/**
 * Set event callbacks for the client.
 *
 * # Safety
 * - `client` must be a valid, non-null pointer.
 */

int32_t dash_spv_ffi_client_set_event_callbacks(struct FFIDashSpvClient *client,
                                                struct FFIEventCallbacks callbacks)
;

/**
 * Destroy the client and free associated resources.
 *
 * # Safety
 * - `client` must be either null or a pointer obtained from `dash_spv_ffi_client_new`.
 */
 void dash_spv_ffi_client_destroy(struct FFIDashSpvClient *client) ;

/**
 * Destroy a `FFISyncProgress` object returned by this crate.
 *
 * # Safety
 * - `progress` must be a pointer returned from this crate, or null.
 */
 void dash_spv_ffi_sync_progress_destroy(struct FFISyncProgress *progress) ;

/**
 * Get the wallet manager from the SPV client
 *
 * Returns a pointer to an `FFIWalletManager` wrapper that clones the underlying
 * `Arc<RwLock<WalletManager>>`. This allows direct interaction with the wallet
 * manager without going back through the client for each call.
 *
 * # Safety
 *
 * The caller must ensure that:
 * - The client pointer is valid
 * - The returned pointer is released exactly once using
 *   `dash_spv_ffi_wallet_manager_free`
 *
 * # Returns
 *
 * A pointer to the wallet manager wrapper, or NULL if the client is not initialized.
 */
 struct FFIWalletManager *dash_spv_ffi_client_get_wallet_manager(struct FFIDashSpvClient *client) ;

/**
 * Release a wallet manager obtained from `dash_spv_ffi_client_get_wallet_manager`.
 *
 * This simply forwards to `wallet_manager_free` in key-wallet-ffi so that
 * lifetime management is consistent between direct key-wallet usage and the
 * SPV client pathway.
 *
 * # Safety
 * - `manager` must either be null or a pointer previously returned by
 *   `dash_spv_ffi_client_get_wallet_manager`.
 */
 void dash_spv_ffi_wallet_manager_free(struct FFIWalletManager *manager) ;

 struct FFIClientConfig *dash_spv_ffi_config_new(FFINetwork network) ;

 struct FFIClientConfig *dash_spv_ffi_config_mainnet(void) ;

 struct FFIClientConfig *dash_spv_ffi_config_testnet(void) ;

/**
 * Sets the data directory for storing blockchain data
 *
 * # Safety
 * - `config` must be a valid pointer to an FFIClientConfig created by dash_spv_ffi_config_new/mainnet/testnet
 * - `path` must be a valid null-terminated C string
 * - The caller must ensure the config pointer remains valid for the duration of this call
 */

int32_t dash_spv_ffi_config_set_data_dir(struct FFIClientConfig *config,
                                         const char *path)
;

/**
 * Adds a peer address to the configuration
 *
 * Accepts socket addresses with or without port. When no port is specified,
 * the default P2P port for the configured network is used.
 *
 * Supported formats:
 * - IP with port: `192.168.1.1:9999`, `[::1]:19999`
 * - IP without port: `127.0.0.1`, `2001:db8::1`
 * - Hostname with port: `node.example.com:9999`
 * - Hostname without port: `node.example.com`
 *
 * # Safety
 * - `config` must be a valid pointer to an FFIClientConfig created by dash_spv_ffi_config_new/mainnet/testnet
 * - `addr` must be a valid null-terminated C string containing a socket address or IP-only string
 * - The caller must ensure both pointers remain valid for the duration of this call
 */

int32_t dash_spv_ffi_config_add_peer(struct FFIClientConfig *config,
                                     const char *addr)
;

/**
 * Sets the user agent string to advertise in the P2P handshake
 *
 * # Safety
 * - `config` must be a valid pointer to an FFIClientConfig created by dash_spv_ffi_config_new/mainnet/testnet
 * - `user_agent` must be a valid null-terminated C string
 * - The caller must ensure both pointers remain valid for the duration of this call
 */

int32_t dash_spv_ffi_config_set_user_agent(struct FFIClientConfig *config,
                                           const char *user_agent)
;

/**
 * Restrict connections strictly to configured peers (disable DNS discovery and peer store)
 *
 * # Safety
 * - `config` must be a valid pointer to an FFIClientConfig created by dash_spv_ffi_config_new/mainnet/testnet
 */

int32_t dash_spv_ffi_config_set_restrict_to_configured_peers(struct FFIClientConfig *config,
                                                             bool restrict_peers)
;

/**
 * Enables or disables masternode synchronization
 *
 * # Safety
 * - `config` must be a valid pointer to an FFIClientConfig created by dash_spv_ffi_config_new/mainnet/testnet
 * - The caller must ensure the config pointer remains valid for the duration of this call
 */

int32_t dash_spv_ffi_config_set_masternode_sync_enabled(struct FFIClientConfig *config,
                                                        bool enable)
;

/**
 * Gets the network type from the configuration
 *
 * # Safety
 * - `config` must be a valid pointer to an FFIClientConfig or null
 * - If null, returns FFINetwork::Dash as default
 */
 FFINetwork dash_spv_ffi_config_get_network(const struct FFIClientConfig *config) ;

/**
 * Destroys an FFIClientConfig and frees its memory
 *
 * # Safety
 * - `config` must be a valid pointer to an FFIClientConfig created by dash_spv_ffi_config_new/mainnet/testnet, or null
 * - After calling this function, the config pointer becomes invalid and must not be used
 * - This function should only be called once per config instance
 */

void dash_spv_ffi_config_destroy(struct FFIClientConfig *config)
;

/**
 * Enables or disables mempool tracking
 *
 * # Safety
 * - `config` must be a valid pointer to an FFIClientConfig created by dash_spv_ffi_config_new/mainnet/testnet
 * - The caller must ensure the config pointer remains valid for the duration of this call
 */

int32_t dash_spv_ffi_config_set_mempool_tracking(struct FFIClientConfig *config,
                                                 bool enable)
;

/**
 * Sets the mempool synchronization strategy
 *
 * # Safety
 * - `config` must be a valid pointer to an FFIClientConfig created by dash_spv_ffi_config_new/mainnet/testnet
 * - The caller must ensure the config pointer remains valid for the duration of this call
 */

int32_t dash_spv_ffi_config_set_mempool_strategy(struct FFIClientConfig *config,
                                                 enum FFIMempoolStrategy strategy)
;

/**
 * Sets whether to fetch full mempool transaction data
 *
 * # Safety
 * - `config` must be a valid pointer to an FFIClientConfig created by dash_spv_ffi_config_new/mainnet/testnet
 * - The caller must ensure the config pointer remains valid for the duration of this call
 */

int32_t dash_spv_ffi_config_set_fetch_mempool_transactions(struct FFIClientConfig *config,
                                                           bool fetch)
;

/**
 * Sets whether to persist mempool state to disk
 *
 * # Safety
 * - `config` must be a valid pointer to an FFIClientConfig created by dash_spv_ffi_config_new/mainnet/testnet
 * - The caller must ensure the config pointer remains valid for the duration of this call
 */

int32_t dash_spv_ffi_config_set_persist_mempool(struct FFIClientConfig *config,
                                                bool persist)
;

/**
 * Sets the starting block height for synchronization
 *
 * # Safety
 * - `config` must be a valid pointer to an FFIClientConfig created by dash_spv_ffi_config_new/mainnet/testnet
 * - The caller must ensure the config pointer remains valid for the duration of this call
 */

int32_t dash_spv_ffi_config_set_start_from_height(struct FFIClientConfig *config,
                                                  uint32_t height)
;

 const char *dash_spv_ffi_get_last_error(void) ;

/**
 * Gets a quorum public key from the Core chain
 *
 * # Safety
 *
 * This function is unsafe because:
 * - The caller must ensure all pointers are valid
 * - quorum_hash must point to a 32-byte array
 * - out_pubkey must point to a buffer of at least out_pubkey_size bytes
 * - out_pubkey_size must be at least 48 bytes
 */

struct FFIResult ffi_dash_spv_get_quorum_public_key(struct FFIDashSpvClient *client,
                                                    uint32_t quorum_type,
                                                    const uint8_t *quorum_hash,
                                                    uint32_t core_chain_locked_height,
                                                    uint8_t *out_pubkey,
                                                    uintptr_t out_pubkey_size)
;

/**
 * Gets the platform activation height from the Core chain
 *
 * # Safety
 *
 * This function is unsafe because:
 * - The caller must ensure all pointers are valid
 * - out_height must point to a valid u32
 */

struct FFIResult ffi_dash_spv_get_platform_activation_height(struct FFIDashSpvClient *client,
                                                             uint32_t *out_height)
;

/**
 * Initialize logging for the SPV library.
 *
 * # Arguments
 * - `level`: Log level string (null uses RUST_LOG env var or defaults to INFO).
 *   Valid values: "error", "warn", "info", "debug", "trace"
 * - `enable_console`: Whether to output logs to console (stderr)
 * - `log_dir`: Directory for log files (null to disable file logging)
 * - `max_files`: Maximum archived log files to retain (ignored if log_dir is null)
 *
 * # Safety
 * - `level` and `log_dir` may be null or point to valid, NUL-terminated C strings.
 */

int32_t dash_spv_ffi_init_logging(const char *level,
                                  bool enable_console,
                                  const char *log_dir,
                                  uintptr_t max_files)
;

 const char *dash_spv_ffi_version(void) ;

#ifdef __cplusplus
}  // extern "C"
#endif  // __cplusplus

#ifdef __cplusplus
}  // namespace dash_spv_ffi
#endif  // __cplusplus

#endif  /* DASH_SPV_FFI_H */
